---
title: "Figure 4"
subtitle: "R code to replicate the analysis"
date: "`r format(Sys.time(), '%d %B, %Y')`"
documentclass: article
mainfont: Lato
output:
  pdf_document:
    toc: yes
    toc_depth: 3
    number_sections: yes
    df_print: kable
    fig_caption: true
    highlight: zenburn
    latex_engine: xelatex 
  html_document:
    code_folding: show
    collapse: no
    df_print: paged
    fig_caption: yes
    fig_height: 4
    fig_width: 4
    highlight: textmate
    theme: united
    toc: yes
    toc_float: yes
    css: "/home/marko-terzin/Documents/PhD/Thesis/Chapter_2/Data_analysis/Seawater/testing_Igor_Antti_R_script/All_seawater_full_dataset/resources/ws_style.css"  
  word_document:
#    fig_caption: yes
#    fig_height: 4
#    fig_width: 4
#    highlight: tango
    toc: yes
#    toc_depth: 2  
# bibliography: ../resources/references.bib
fontsize: 11pt
geometry: margin=1in
classoption: a4paper
abstract: This is the code to make Fig. 4 (and all the relevant supplementary figures/tables). 
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r Loading libraries, results = "hide", eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE}
# First checking if I have the packages I need, and installing if not
list.of.packages <- c("tidyverse", "gplots", "RColorBrewer", "networkD3", "vegan", "rstatix", 
                      "ggalluvial", "gridExtra", "propr", "patchwork", "phyloseq", "dplyr", 
                      "VennDiagram", "plyr", "data.table", "vsn", "pheatmap", "ggpubr", 
                      "microbiome", "rmarkdown", "mixOmics", "NetCoMi", "igraph", "randomForest", 
                      "caret", "pdp", "rstatix")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)

# Installing some separately:
# phyloseq
# if (!requireNamespace("BiocManager", quietly = TRUE))
# install.packages("BiocManager")

# BiocManager::install("phyloseq")

# DESeq2
# BiocManager::install("DESeq2")

# vsn
# BiocManager::install("vsn")

# Had issues installing tidyverse, so I followed this first (insttalled some dependencies from the terminal) and then it worked: https://community.rstudio.com/t/tidyverse-package-does-not-install/162507/6
library(tidyverse)
library(gplots)
library(RColorBrewer)
library(ggrepel)
library(units)
library(future) # Needed to use multiple processors
library(furrr) # Needed to use multiple processors
library(progressr) # to track the progress
library(networkD3) # for Sankey diagrams
library(vegan)
library(rstatix)
library(parallel) # for setting multiple CPUs
library(ggalluvial) # to create alluvial diagrams
library(gridExtra)
# library(propr) # to compute the proportionality metric!
library(patchwork)
library(phyloseq)
library(ggnewscale)
library(dplyr)
library(VennDiagram)
# if (!require(devtools)) install.packages("devtools")
# devtools::install_github("gaospecial/ggVennDiagram")
library(ggVennDiagram)
library(ggvenn)
library(plyr) # Needed for the ordination plots I did on my own
library(data.table) # For data wrangling
library(vsn) # For normalization
# library(psych) # Used to investigate correlations among predictors in RDA analysis, ran in vegan
library(RColorBrewer)
library(pheatmap)
library(ggpubr) # has ggarrange
# EcolUtils by Guillem Salazar
library(devtools)
# devtools::install_github("GuillemSalazar/EcolUtils")
library(EcolUtils)
# Install pairwiseAdonis
# devtools::install_github("pmartinezarbizu/pairwiseAdonis/pairwiseAdonis")
library(pairwiseAdonis)
# install.packages("remotes")
# remotes::install_github("microbiome/microbiome")
library(microbiome)
# install.packages("rmarkdown")
library(rmarkdown)
library(mixOmics)
# Installing the most important package - mixOmics!
# Install mixOmics
# BiocManager::install('mixOmics')
# library(pairwiseAdonis)

# Installing the NetCoMi package I will need for microbial networks: https://github.com/stefpeschel/NetCoMi
# install.packages("devtools")
# install.packages("BiocManager")
library(doParallel)
library(foreach)
# Install NetCoMi
# devtools::install_github("stefpeschel/NetCoMi", 
#                         dependencies = c("Depends", "Imports", "LinkingTo"),
#                         repos = c("https://cloud.r-project.org/",
#                                   BiocManager::repositories()))
library(NetCoMi)
library(igraph) # needed for the function below: read_graph
# Now installing propr - to compute proportionality metric (microbial networks)
# devtools::install_github("tpq/propr")
# library(propr)

# For random forest models:
library(randomForest)
library(caret)  # For data splitting and model evaluation
library(pdp)

# Packages I need for the map:
library(reshape2) # This is only needed for the melt funtion
library(reshape)
library(dplyr)
library(plyr)
library(data.table)
library(ggplot2)
library(rworldmap)
library(rworldxtra)
# library(ggsn)
library(sf)
library(raster)
library(terra)
# library(rgeos)
# library(maps)
# library(maptools)
library(grid)
library(miscTools)
library(stringr)
library(ggpubr)
library(plyr)
library(gridExtra) # for arranging plots

# Loading all the libraries
library(raster)
library(phyloseq)
library(tidyverse)
library(ggspatial)
library(ggrepel) # The package ggrepel offers a very flexible approach to deal with label placement (with geom_text_repel and 
# geom_label_repel), including automated movement of labels in case of overlap
# Installing AIMS packages individually
library(remotes) # Needed to install the AIMS R packages below
# remotes::install_github("https://github.com/open-AIMS/dataaimsr")
library(dataaimsr)
# remotes::install_github("https://github.com/open-AIMS/gisaimsr")
library(gisaimsr)
library(sp)

# Importing the R object
load("/home/marko-terzin/Documents/PhD/Thesis/Chapter_3_IMOS-MGD_MAGs/cleaned_code/Figure_4/Figure_4.RData")

# Setting the work directory
setwd("/home/marko-terzin/Documents/PhD/Thesis/Chapter_3_IMOS-MGD_MAGs")
```

# Microbial streamlining theory

Let's also overlay genome size and GC content information into this plot, only for the MINT sPLS indicator pMAGs

```{r GC barplots, fig.height=30, fig.width=5, eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE}
### Object with info on genome size, taxonomy, and etc.
# pMAGs_95ANI_stats
### This is my object that already has the MINT sPLS indicators and whether they were also selected as indicators in MINT sPLS-DA
MINT_sPLS_CheckM_stats <- MINT_sPLS_loading.plots.rawgraphs.sectors
### Before merging them, formating my objects accordingly

# Let's first make sure that I write "Not_discriminative_in_MINT_sPLS-DA"
MINT_sPLS_CheckM_stats[is.na(MINT_sPLS_CheckM_stats)] <- "Not_discriminative_in_MINT_sPLS-DA"
# Now let's make the Overall_GroupContrib column
MINT_sPLS_CheckM_stats$Overall_GroupContrib <- apply(MINT_sPLS_CheckM_stats[, c("X01_Cape_Grenville.GroupContrib", "X02_Princess_Charlotte_bay.GroupContrib", "X03_Cairns.GroupContrib", "X04_Innisfail.GroupContrib", "X05_Townsville.GroupContrib", "X06_Swains.GroupContrib", "X07_Capricorn_Bunker.GroupContrib")], 1, function(row) {
  # Count the occurrences of "O", "C", and "Not_discriminative_in_MINT_sPLS-DA"
  o_count <- sum(row == "O")
  c_count <- sum(row == "C")
  non_indicative_count <- sum(row == "Not_discriminative_in_MINT_sPLS-DA")
  
  # Check if "Not_discriminative_in_MINT_sPLS-DA" is in the row
  if (non_indicative_count > 0) {
    return("Not_discriminative_in_MINT_sPLS-DA")
  }
  
  # Assign "O" or "C" based on prevalence
  if (o_count > c_count) {
    return("O")
  } else {
    return("C")
  }
})
# Looks good! Now adding the CheckM stats for these pMAGs
MINT_sPLS_CheckM_stats <- left_join(MINT_sPLS_CheckM_stats,
                                    pMAGs_95ANI_stats,
                                    by = c("OTU" = "Katherine_names_876_bins"))

# Plotting GC as barplots!
GC_content_barplots <- MINT_sPLS_CheckM_stats %>% # five is indicator colors, 23 is genome size
#  unite(OTU, c(OTU, taxonomy), sep = "; ") %>% # Trying to add taxonomy here but then the ordering deosn't work...
  ggplot(aes(y=factor(OTU, level = unique(MINT_sPLS_loading.plots.rawgraphs.sectors$OTU)), # ordering the same way as the MAGs are ordered in the loading plots
             x = GC.CheckM1,
             fill = Overall_GroupContrib)) +
  geom_bar(stat = "identity", show.legend = FALSE) +
    scale_fill_manual(values = c("seagreen3", # C for No-take zones
#                                 "darkgray", # Not_discriminative_in_MINT_sPLS-DA
                               "steelblue4")) + # O for Take zones
  labs(y = 'MINT sPLS Indicator pMAGs95%ANI',
       x = "GC content (%)",
       title = 'GC content (%)') +
      theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 12), legend.position = "NONE") +
  theme_bw() +
  scale_x_continuous(limits = c(0,100))  +
  scale_y_discrete(limits=rev)
#    scale_y_discrete(limits=rev)
#    scale_x_continuous(limits = c(0, 100))
```

```{r Genome size barplots, fig.height=30, fig.width=5, eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE}
# Plotting as barplots!
Genome_size_barplots <- MINT_sPLS_CheckM_stats %>% # five is indicator colors, 23 is genome size
#  unite(OTU, c(OTU, taxonomy), sep = "; ") %>% # Trying to add taxonomy here but then the ordering deosn't work...
  ggplot(aes(y=factor(OTU, level = unique(MINT_sPLS_loading.plots.rawgraphs.sectors$OTU)), # ordering the same way as the MAGs are ordered in the loading plots
             x = Genome.size..bp..CheckM1,
             fill = Overall_GroupContrib)) +
  geom_bar(stat = "identity", show.legend = FALSE) +
    scale_fill_manual(values = c("seagreen3", # C for No-take zones
#                                 "darkgray", # Not_discriminative_in_MINT_sPLS-DA
                               "steelblue4")) + # O for Take zones
  labs(y = 'MINT sPLS Indicator pMAGs95%ANI',
       x = "Genome size (bp)",
       title = 'Genome size (bp)') +
      theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 12), legend.position = "NONE") +
  theme_bw() +
  scale_y_discrete(limits=rev)
```

```{r GC content medians boxplots, fig.height=3, fig.width=3, eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE}
GC_stats <- ddply(MINT_sPLS_CheckM_stats %>% 
                    column_to_rownames("OTU") %>% 
                    dplyr::select("Overall_GroupContrib", "GC.CheckM1"),
                  .(Overall_GroupContrib), # Specify the grouping variable
                  summarise,
                  Median_GC = median(GC.CheckM1, na.rm = TRUE),
                  SD_GC = sd(GC.CheckM1, na.rm = TRUE)
)

# Plotting
GC_boxplots <- MINT_sPLS_CheckM_stats %>%   
  ggplot() +
  geom_boxplot(aes(y = GC.CheckM1,
                   x = Overall_GroupContrib,
                   fill = Overall_GroupContrib),
               show.legend = FALSE,
               outliers = F) + # just fill as in Trip 2
      geom_jitter(aes(y = GC.CheckM1, 
                  x = Overall_GroupContrib 
#                  color = Overall_GroupContrib
),
              width = 0.2, # adjust width to control the spread of the points
              size = 1.2,   # adjust size for better visibility
              alpha = 0.1) + # adjust transparency if needed
  geom_text(data = GC_stats, 
            aes(x = Overall_GroupContrib, 
                y = Median_GC + 5, # Adjust y position for visibility
                label = paste(round(Median_GC, 2), "±", round(SD_GC, 2))),
            color = "black", 
            size = 4.5, 
            vjust = 0) + # Adjust vertical justification as needed
#  facet_grid(~Sampling_trip) +
  labs(title="GC content (%)",
       y="GC content",
       x="Reef Zoning Status") +
    scale_fill_manual(values = c("seagreen3", # C for No-take zones
#                                 "darkgray", # Not_discriminative_in_MINT_sPLS-DA
                               "steelblue4")) + # O for Take zones
  scale_y_continuous(limits = c(0, 100)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 12), legend.position = "none") +
  stat_pvalue_manual(MINT_sPLS_CheckM_stats %>% 
                       pairwise_wilcox_test(GC.CheckM1 ~ Overall_GroupContrib) %>%
                       add_xy_position())
```

```{r Genome size boxplots, fig.height=3, fig.width=3, eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE, results='hide', fig.show='hide'}
Genome_size_stats <- ddply(MINT_sPLS_CheckM_stats %>% 
                             column_to_rownames("OTU") %>% 
                             dplyr::select("Overall_GroupContrib", "Genome.size..bp..CheckM1"),
                           .(Overall_GroupContrib), # summarise based on the group of interest
                           summarise,
                           Median_Genome_size = median(Genome.size..bp..CheckM1, na.rm = TRUE),
                           SD_Genome_size = sd(Genome.size..bp..CheckM1, na.rm = TRUE))

# Plotting
genome_size_boxplots <- MINT_sPLS_CheckM_stats %>%   
  ggplot() +
  geom_boxplot(aes(y = Genome.size..bp..CheckM1,
                   x = Overall_GroupContrib,
                   fill = Overall_GroupContrib),
               show.legend = FALSE) + # just fill as in Trip 2
      geom_jitter(aes(y = Genome.size..bp..CheckM1, 
                  x = Overall_GroupContrib 
#                  color = Overall_GroupContrib
),
              width = 0.2, # adjust width to control the spread of the points
              size = 1.2,   # adjust size for better visibility
              alpha = 0.1) + # adjust transparency if needed
  geom_text(data = Genome_size_stats, 
            aes(x = Overall_GroupContrib, 
                y = Median_Genome_size + 5, # Adjust y position for visibility
                label = paste(round(Median_Genome_size, 2), "±", round(SD_Genome_size, 2))),
            color = "black", 
            size = 4.5, 
            vjust = 0) + # Adjust vertical justification as needed
#  facet_grid(~Sampling_trip) +
  labs(title="Genome size (bp)",
       y="Genome size (bp)",
       x="Reef Zoning Status") +
    scale_fill_manual(values = c("seagreen3", # C for No-take zones
#                                 "darkgray", # Not_discriminative_in_MINT_sPLS-DA
                               "steelblue4")) + # O for Take zones
  scale_y_continuous(limits = c(0, 5500000)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 12), legend.position = "none") +
  stat_pvalue_manual(MINT_sPLS_CheckM_stats %>% 
                       pairwise_wilcox_test(Genome.size..bp..CheckM1 ~ Overall_GroupContrib) %>%
                       add_xy_position())
```

Apart from having different GC content and genome sizes, these indicator microbes may also be different in terms of KEGG pathway completeness - increased completeness might be a proxy of microbial opportunism. In contrast, with genome streamlining we can also expect to see gene loss. 

Let's take a look: 

```{r Importing KEGG data, eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE}
# Importing our KEGG annotations 
KEGGs_all_876_95ANI_MAGs <- read.delim("/home/marko-terzin/Documents/PhD/Thesis/Chapter_3_IMOS-MGD_MAGs/KEGGs_analysis/KEGGs_for_876_MAGs_95ANI_CoverM_Katherine.txt")
# Adding the GTDB R214 taxonomy:
# Remove 'IMOS__' prefix from 'genome_name' column
KEGGs_all_876_95ANI_MAGs$genome_name <- sub('^IMOS__', '', KEGGs_all_876_95ANI_MAGs$genome_name)
# Remove 'prok_' prefix from 'genome_name' column
KEGGs_all_876_95ANI_MAGs$genome_name <- sub('prok__', '', KEGGs_all_876_95ANI_MAGs$genome_name)

KEGGs_all_876_95ANI_MAGs_GTDB <- left_join(KEGGs_all_876_95ANI_MAGs, 
                                           pMAGs_95ANI_phyloseq_CLR_per_sector@tax_table %>% 
                                             as.data.frame() %>% 
                                             rownames_to_column("genome_name")
                                           ) %>% 
  tidyr::unite(GTDB_taxonomy, Domain, Phylum, Class, Order, Family, Genus, Species, sep = "; ")

# Only selecting the MINT sPLS indicator pMAGs
KEGG_indicators_MINT_sPLS <- left_join(MINT_sPLS_CheckM_stats %>% 
                               dplyr::select("OTU", "Overall_GroupContrib"),
                             KEGGs_all_876_95ANI_MAGs_GTDB,
                              by = c("OTU" = "genome_name")
)
```

```{r Plotting KEGG completeness scores for MINT sPLS indicators, fig.width = 100, fig.height=60, eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE}
# Pivot data to have module_name as columns and stepwise_module_completeness as values
KEGG_indicators_MINT_sPLS_heatmap_data <- KEGG_indicators_MINT_sPLS %>%
  dplyr::select(OTU, GTDB_taxonomy, module_name, stepwise_module_completeness) %>% # just selecting the columns of interest
  pivot_wider(names_from = module_name, values_from = stepwise_module_completeness) %>% 
  as.data.frame()

# Combine OTU and GTDB taxonomy into a single identifier for rows
KEGG_indicators_MINT_sPLS_heatmap_data$OTU_GTDB <- paste(KEGG_indicators_MINT_sPLS_heatmap_data$OTU,
                                                         KEGG_indicators_MINT_sPLS_heatmap_data$GTDB_taxonomy,
                                                         sep = "_")
# Formatting for pheatmap
KEGGs_for_pheatmap_MINT_sPLS_indicators <- KEGG_indicators_MINT_sPLS_heatmap_data %>% 
  column_to_rownames("OTU_GTDB") %>% 
  dplyr::select(-OTU, -GTDB_taxonomy) %>% 
  t() %>% 
  as.data.frame()

# But I cannot plot NAs... Let's check how many I have:
any(is.na(KEGGs_for_pheatmap_MINT_sPLS_indicators))
# If any of these checks return TRUE, handle these values appropriately - replacing with a zero:
KEGGs_for_pheatmap_MINT_sPLS_indicators[is.na(KEGGs_for_pheatmap_MINT_sPLS_indicators)] <- 0
# These will now be plotted in grey

# Reorder the columns of KEGGs_for_pheatmap
MINT_sPLS_indicators_KEGG_module_completeness <- left_join(MINT_sPLS_CheckM_stats %>% 
                                                             dplyr::select("OTU", "Overall_GroupContrib"),
                                                      KEGG_indicators_MINT_sPLS_heatmap_data %>% 
                                                        dplyr::select(OTU, GTDB_taxonomy) %>% 
                                                        distinct(OTU, .keep_all = TRUE))
MINT_sPLS_indicators_KEGG_module_completeness$OTU_GTDB <- paste(MINT_sPLS_indicators_KEGG_module_completeness$OTU,
                                                           MINT_sPLS_indicators_KEGG_module_completeness$GTDB_taxonomy,
                                                           sep = "_")
# MINT_sPLS_indicators_KEGG_module_completeness <- MINT_sPLS_indicators_KEGG_module_completeness %>% 
#  dplyr::select(-OTU, -GTDB_taxonomy) %>% 
#  as.data.frame()

# Extract the order from loading.plots.rawgraphs.sectors_taxonomy
heatmap_data_OTU_order <- left_join(MINT_sPLS_loading.plots.rawgraphs.sectors %>% dplyr::select("OTU"),
                                    MINT_sPLS_indicators_KEGG_module_completeness %>% dplyr::select(c("OTU", "OTU_GTDB"))
) %>% 
  mutate(OTU_GTDB = gsub("_d__", "; d__", OTU_GTDB))


ordered_pMAGs_MINT_sPLS <- heatmap_data_OTU_order$OTU_GTDB

# Use gsub to replace "_d_Bacteria" with "; d_Bacteria" and "_d_Archaea" with "; d_Archaea"
colnames(KEGGs_for_pheatmap_MINT_sPLS_indicators) <- gsub("_d__Bacteria", "; d__Bacteria", colnames(KEGGs_for_pheatmap_MINT_sPLS_indicators))
colnames(KEGGs_for_pheatmap_MINT_sPLS_indicators) <- gsub("_d__Archaea", "; d__Archaea", colnames(KEGGs_for_pheatmap_MINT_sPLS_indicators))

# Reorder the columns in KEGGs_for_pheatmap to match the order in ordered_OTUs
KEGGs_for_pheatmap_ordered_MINT_sPLS_Indicators <- KEGGs_for_pheatmap_MINT_sPLS_indicators[, ordered_pMAGs_MINT_sPLS, drop = FALSE]

# Create a custom color palette
my_colors <- colorRampPalette(c("snow2", "lightsalmon"))(6) # Color gradient for non-NA values
my_colors <- c(my_colors, "red4")  # Color complete pathways in red

# Define a color function to handle NA values
# na_color_function <- function(x) {
#  colors <- colorRampPalette(c("snow2", "lightsalmon"))(6)
#  colors <- c(colors, "white")
#  return(colors[findInterval(x, c(seq(min(x, na.rm = TRUE), max(x, na.rm = TRUE), length.out = 50)), Inf)])
#W }

# Apply the color function in pheatmap
pheatmap(
  as.matrix(KEGGs_for_pheatmap_ordered_MINT_sPLS_Indicators),
  cluster_cols = FALSE,
  cluster_rows = TRUE,
  clustering_distance_rows = "euclidean",
  clustering_method = "complete",
  color = my_colors,
  scale = "none",
  show_rownames = TRUE,
  show_colnames = TRUE,
  fontsize = 10,
  cellwidth = 15,
  cellheight = 10,
  na_col = "white",  # Specify grey for NA values
  border_color = NA  # Remove cell borders
)
```

```{r Plotting averaged KEGG completeness scores for MINT sPLS indicators, fig.width = 14, fig.height=45, eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE}
### Ordered as in the MINT sPLS-DA heatmap

# Compute the average KEGG completeness for each sample (column)
MINT_sPLS_indicators_average_KEGG_completeness_per_MAG <- colMeans(KEGGs_for_pheatmap_ordered_MINT_sPLS_Indicators, na.rm = TRUE) %>% 
  as.data.frame()
# Set column names
colnames(MINT_sPLS_indicators_average_KEGG_completeness_per_MAG) <- "average_KEGG_completeness_per_MAG"

# Scaling the values now:
scaled_average_KEGG_completeness_per_MAG_MINT_sPLS_indicators <- scale(MINT_sPLS_indicators_average_KEGG_completeness_per_MAG)

# Step 2: Creating the custom color palette
KEGG_my_colors <- colorRampPalette(c("royalblue4", "white", "indianred4"))(100)

# Apply the color function in pheatmap
pheatmap(
  as.matrix(scaled_average_KEGG_completeness_per_MAG_MINT_sPLS_indicators),
  cluster_cols = FALSE,
  cluster_rows = FALSE,
  color = KEGG_my_colors,
  scale = "none",
  show_rownames = TRUE,
  show_colnames = TRUE,
  na_col = "white",  # Specify grey for NA values
  border_color = NA  # Remove cell borders
)
```

Let's make barplots too:

```{r KEGG completeness barplots, fig.height=30, fig.width=5, eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE, results='hide', fig.show='hide'}
# Plotting GC as barplots!
KEGG_completeness_barplots <- MINT_sPLS_CheckM_stats_and_average_KEGG_completeness %>% # five is indicator colors, 23 is genome size
#  unite(OTU, c(OTU, taxonomy), sep = "; ") %>% # Trying to add taxonomy here but then the ordering deosn't work...
  ggplot(aes(y=factor(OTU, level = unique(MINT_sPLS_loading.plots.rawgraphs.sectors$OTU)), # ordering the same way as the MAGs are ordered in the loading plots
             x = average_KEGG_completeness_per_MAG,
             fill = Overall_GroupContrib)) +
  geom_bar(stat = "identity", show.legend = FALSE) +
    scale_fill_manual(values = c("seagreen3", # C for No-take zones
#                                 "darkgray", # Not_discriminative_in_MINT_sPLS-DA
                               "steelblue4")) + # O for Take zones
  labs(y = 'MINT sPLS Indicator pMAGs95%ANI',
       x = "KEGG completenes across 319 modules (0-1)",
       title = 'KEGG completenes across 319 modules (0-1)') +
      theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 12), legend.position = "NONE") +
  theme_bw() +
  scale_x_continuous(limits = c(0,0.5)) +
  scale_y_discrete(limits=rev)
#    scale_x_continuous(limits = c(0, 100)
```

```{r KEGG completeness boxplots, fig.height=3, fig.width=3, eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE, results='hide', fig.show='hide'}
# Replace "_d_Bacteria" with "; d_Bacteria" and "_d_Archaea" with "; d_Archaea" in the OTU_GTDB column
# MINT_sPLS_CheckM_stats$OTU_GTDB <- gsub("_d__Bacteria", "; d__Bacteria", MINT_sPLS_CheckM_stats$OTU_GTDB)
# MINT_sPLS_CheckM_stats$OTU_GTDB <- gsub("_d__Archaea", "; d__Archaea", MINT_sPLS_CheckM_stats$OTU_GTDB)
MINT_sPLS_CheckM_stats$OTU_GTDB <- gsub(";", "; ", 
                                       paste(MINT_sPLS_CheckM_stats$OTU,
                                             MINT_sPLS_CheckM_stats$GTDBtk.classification..R214.,
                                             sep = ";"))

# OK, let's add the average KEGG completeness info into the MINT_sPLS_CheckM_stats object
MINT_sPLS_CheckM_stats_and_average_KEGG_completeness <- left_join(MINT_sPLS_CheckM_stats,
                                                               MINT_sPLS_indicators_average_KEGG_completeness_per_MAG %>%
                                                                  rownames_to_column("OTU_GTDB"))
KEGG_modules_completeness_stats <- ddply(MINT_sPLS_CheckM_stats_and_average_KEGG_completeness %>% 
                             column_to_rownames("OTU") %>% 
                             dplyr::select("Overall_GroupContrib", "average_KEGG_completeness_per_MAG"),
                           .(Overall_GroupContrib), # summarise based on the group of interest
                           summarise,
                           Median_KEGG_completeness = median(average_KEGG_completeness_per_MAG, na.rm = TRUE),
                           SD_KEGG_completeness = sd(average_KEGG_completeness_per_MAG, na.rm = TRUE))

# Plotting
KEGG_completeness_boxplots <- MINT_sPLS_CheckM_stats_and_average_KEGG_completeness %>%   
  ggplot() +
  geom_boxplot(aes(y = average_KEGG_completeness_per_MAG,
                   x = Overall_GroupContrib,
                   fill = Overall_GroupContrib),
               show.legend = FALSE) + # just fill as in Trip 2
      geom_jitter(aes(y = average_KEGG_completeness_per_MAG, 
                  x = Overall_GroupContrib 
#                  color = Overall_GroupContrib
),
              width = 0.2, # adjust width to control the spread of the points
              size = 1.2,   # adjust size for better visibility
              alpha = 0.1) + # adjust transparency if needed
  geom_text(data = KEGG_modules_completeness_stats, 
            aes(x = Overall_GroupContrib, 
                y = Median_KEGG_completeness + 0.1, # Adjust y position for visibility
                label = paste(round(Median_KEGG_completeness, 2), "±", round(SD_KEGG_completeness, 2))),
            color = "black", 
            size = 4.5, 
            vjust = 0) + # Adjust vertical justification as needed
#  facet_grid(~Sampling_trip) +
  labs(title="completeness KEGG modules (0-1)",
       y="KEGG module completeness (0-1)",
       x="Reef Zoning Status") +
    scale_fill_manual(values = c("seagreen3", # C for No-take zones
#                                 "darkgray", # Not_discriminative_in_MINT_sPLS-DA
                               "steelblue4")) + # O for Take zones
  scale_y_continuous(limits = c(0, 0.5)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 12), legend.position = "none") +
  stat_pvalue_manual(MINT_sPLS_CheckM_stats_and_average_KEGG_completeness %>% 
                       pairwise_wilcox_test(average_KEGG_completeness_per_MAG ~ Overall_GroupContrib) %>%
                       add_xy_position())
```

OK so it's clear, indicators of No-Take reefs (with smaller genomes and lower GC) also have more incomplete pathways!

But let's also check the CheckM1 and CheckM2 completeness scores, and if they are any different:

```{r CheckM1 completeness boxplots, fig.height=3, fig.width=3, eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE, results='hide', fig.show='hide'}
CheckM1_completeness_stats <- ddply(MINT_sPLS_CheckM_stats_and_average_KEGG_completeness %>% 
                             column_to_rownames("OTU") %>% 
                             dplyr::select("Overall_GroupContrib", "Completeness.CheckM1"),
                           .(Overall_GroupContrib), # summarise based on the group of interest
                           summarise,
                           Median_CheckM1_completeness = median(Completeness.CheckM1, na.rm = TRUE),
                           SD_CheckM1_completeness = sd(Completeness.CheckM1, na.rm = TRUE))

CheckM1_compl_boxplots <- MINT_sPLS_CheckM_stats_and_average_KEGG_completeness %>%   
  ggplot() +
  geom_boxplot(aes(y = Completeness.CheckM1,
                   x = Overall_GroupContrib,
                   fill = Overall_GroupContrib),
               show.legend = FALSE) + # just fill as in Trip 2
      geom_jitter(aes(y = Completeness.CheckM1, 
                  x = Overall_GroupContrib 
#                  color = Overall_GroupContrib
),
              width = 0.2, # adjust width to control the spread of the points
              size = 1.2,   # adjust size for better visibility
              alpha = 0.1) + # adjust transparency if needed
  geom_text(data = CheckM1_completeness_stats, 
            aes(x = Overall_GroupContrib, 
                y = Median_CheckM1_completeness + 0.1, # Adjust y position for visibility
                label = paste(round(Median_CheckM1_completeness, 2), "±", round(SD_CheckM1_completeness, 2))),
            color = "black", 
            size = 4.5, 
            vjust = 0) + # Adjust vertical justification as needed
#  facet_grid(~Sampling_trip) +
  labs(title="CheckM1 completeness",
       y="CheckM1 completeness",
       x="Reef Zoning Status") +
    scale_fill_manual(values = c("seagreen3", # C for No-take zones
#                                 "darkgray", # Not_discriminative_in_MINT_sPLS-DA
                               "steelblue4")) + # O for Take zones
  scale_y_continuous(limits = c(0, 100)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 12), legend.position = "none") +
  stat_pvalue_manual(MINT_sPLS_CheckM_stats_and_average_KEGG_completeness %>% 
                       pairwise_wilcox_test(Completeness.CheckM1 ~ Overall_GroupContrib) %>%
                       add_xy_position())
```

```{r CheckM2 completeness boxplots, fig.height=3, fig.width=3, eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE, results='hide', fig.show='hide'}
CheckM2_completeness_stats <- ddply(MINT_sPLS_CheckM_stats_and_average_KEGG_completeness %>% 
                             column_to_rownames("OTU") %>% 
                             dplyr::select("Overall_GroupContrib", "Completeness_default.CheckM2"),
                           .(Overall_GroupContrib), # summarise based on the group of interest
                           summarise,
                           Median_CheckM2_completeness = median(Completeness_default.CheckM2, na.rm = TRUE),
                           SD_CheckM2_completeness = sd(Completeness_default.CheckM2, na.rm = TRUE))

CheckM2_compl_boxplots <- MINT_sPLS_CheckM_stats_and_average_KEGG_completeness %>%   
  ggplot() +
  geom_boxplot(aes(y = Completeness_default.CheckM2,
                   x = Overall_GroupContrib,
                   fill = Overall_GroupContrib),
               show.legend = FALSE) + # just fill as in Trip 2
      geom_jitter(aes(y = Completeness_default.CheckM2, 
                  x = Overall_GroupContrib 
#                  color = Overall_GroupContrib
),
              width = 0.2, # adjust width to control the spread of the points
              size = 1.2,   # adjust size for better visibility
              alpha = 0.1) + # adjust transparency if needed
  geom_text(data = CheckM2_completeness_stats, 
            aes(x = Overall_GroupContrib, 
                y = Median_CheckM2_completeness + 0.1, # Adjust y position for visibility
                label = paste(round(Median_CheckM2_completeness, 2), "±", round(SD_CheckM2_completeness, 2))),
            color = "black", 
            size = 4.5, 
            vjust = 0) + # Adjust vertical justification as needed
#  facet_grid(~Sampling_trip) +
  labs(title="CheckM2 completeness",
       y="CheckM2 completeness",
       x="Reef Zoning Status") +
    scale_fill_manual(values = c("seagreen3", # C for No-take zones
#                                 "darkgray", # Not_discriminative_in_MINT_sPLS-DA
                               "steelblue4")) + # O for Take zones
  scale_y_continuous(limits = c(0, 100)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 12), legend.position = "none") +
  stat_pvalue_manual(MINT_sPLS_CheckM_stats_and_average_KEGG_completeness %>% 
                       pairwise_wilcox_test(Completeness_default.CheckM2 ~ Overall_GroupContrib) %>%
                       add_xy_position())
```

```{r CheckM completeness boxplots together, fig.height=4, fig.width=6, eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE, results='hide', fig.show='hide'}
patchwork::wrap_plots(CheckM1_compl_boxplots,
                      CheckM2_compl_boxplots,
                      nrow = 1,
                      ncol = 2)
```

# Cohesion metric

Herren and McMahon (2017) introduced a new network metric, called community ***cohesion***, that quantifies the degree of connectivity within a microbial community. The input data is the taxon ***relative abundance table***, and the outputs of the Herren and McMahon (2017) workflow are measurements of the connectivity of each sampled community, which they call ***community ‘cohesion’*** (metric per sample), and their workflow also produces metrics of the ***connectedness*** of each taxon. This is how cohesion is computed:

(1) The workflow begins by calculating the pairwise correlation matrix between taxa (***in our case, the 1071 IMOS MGD MAGs dereplicated at 95% ANI***), using all samples. The data frame looks like this: ***samples in rows, and microbes/MAGs as columns.*** 
(2) A null model is then used to account for bias in these correlations due to the skewed distribution of taxon abundances (that is, many small values and a few large values) and the compositional/relativized nature of the sequencing data (that is, all rows sum to 1). These ‘expected’ correlations generated from the null model (***estimated correlations when they are random and therefore NOT TRUE***) are subtracted off the observed correlations to obtain a matrix of ***corrected*** correlations.
(3) ***For each taxon***, the average positive corrected correlation and average negative corrected correlation are recorded as the ***connectedness*** values.
(4) As previously noted, the goal was to create a metric of connectivity for each community; thus, the next step in the workflow calculates cohesion values for each sample. ***Cohesion is calculated by multiplying the relative abundance of each taxon in a sample by its associated connectedness values, then summing the products of all taxa in a sample***. There are two metrics of cohesion, because we separately calculate metrics based on the positive and negative relationships between taxa. Negative and positive cohesion range from −1 to 0 and 0 to 1, respectively, with higher absolute values signifying more and/or stronger correlations.

Biologically, ***higher negative cohesion in a community (sample!) would indicate a prevalence of negative/mutually exclusive microbial interactions*** - competition, ammensalism, niche divergence, pathogen/host, parasite/host, and predator-prey interactions... In contrast, ***high positive cohesion is a proxy of positive microbial interactions - mutualism, commensalism, niche overlap, and positive feedback loops (i.e. due to metabolic co-dependency)***. Hernandez et al. (2021) used this cohesion metric to quantify how environmental stress in soil (i.e. low nutrients and water) may destabilise soil microbial communities. 

Questions/hypotheses that I want to answer with ***network cohesion*** for the IMOS-MGD data:
(1) ***a prevalence of negative interactions (predator/prey, pathogen/host, competition) in reefs with elevated nutrients*** - seawater microbes (opportunistic) are likely competing for those nutrients. In contrast, microbial communities in reefs with low nutrients may be more likely to exchange nutrients as they are already scarce, so I would expect to see ***an increase in positive cohesion in nutrient-depleted reefs*** - i.e. during winter.
(2) ***Can we link microbial diversity to cohesion too?*** Once opportunistic microbes start outcompeting other microbes in the community in high nutrient conditions, we may observe a drop in overall microbial diversity due to loss of species (that cannot compete) and also a change in eveness. Therefore I expect (1) ***positive correlation between mutualistic interactions and high microbial diversity***, as well as (2) ***positive correlation between negative interactions and low microbial diversity***. 
Questions/hypotheses that I want to answer with ***network connectedness*** for the IMOS-MGD data:
(3) ***Positive correlation between negative cohesion and (1) genome size, (2) GC content, and (3) metabolic independence***. Large genomes, high GC content (~60%) and high metabolic independence (measured as completeness of KEGG metabolic pathways in Veseli et al. 2023) are characteristic of opportunistic microbes, which outcompete (competition would be measured as negative cohesion) other microbes for nutrients.

Trying to answer these questions below one by one.

## Hypothesis 1 - we will observe a ***prevalence of positive interactions when nutrients are low*** (potential proxy of metabolic exchange) and ***negative interactions when nutrients are high*** (potential proxy for microbial competition).

```{r Generating the necessary functions for Cohesion, eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE}
# Online script to generate cohesion metrics for a set of samples 
# CMH 06Dec17; cherren@wisc.edu

# User instructions: read in a sample table (in absolute or relative abundance) as object "b".
# If using a custom correlation matrix, read in that matrix at the designated line.
# Run the entire script, and the 4 vectors (2 of connectedness and 2 of cohesion) are generated for each sample at the end.
# Parameters that can be adjusted include pers.cutoff (persistence cutoff for retaining taxa in analysis), 
# iter (number of iterations for the null model), tax.shuffle (whether to use taxon shuffle or row shuffle randomization), 
# and use.custom.cors (whether to use a pre-determined correlation matrix)

####################create necessary functions######################

#find the number of zeroes in a vector
zero <- function(vec){
  num.zero <- length(which(vec == 0))
  return(num.zero)
}

#create function that averages only negative values in a vector
neg.mean <- function(vector){
  neg.vals <- vector[which(vector < 0)]
  n.mean <- mean(neg.vals)
  if(length(neg.vals) == 0) n.mean <- 0
  return(n.mean)
}

#create function that averages only positive values in a vector
pos.mean <- function(vector){
  pos.vals <- vector[which(vector > 0)]
  p.mean <- mean(pos.vals)
  if(length(pos.vals) == 0) p.mean <- 0
  return(p.mean)
}

###################################################################
###################################################################
### Workflow options ####
###################################################################
###################################################################

## Choose a persistence cutoff (min. fraction of taxon presence) for retaining taxa in the analysis
pers.cutoff <- 0.10
## Decide the number of iterations to run for each taxon. (>= 200 is recommended)
# Larger values of iter mean the script takes longer to run
iter <- 200
## Decide whether to use taxon/column shuffle (tax.shuffle = T) or row shuffle algorithm (tax.shuffle = F)
tax.shuffle <- T
## Option to input your own correlation table
# Note that your correlation table MUST have the same number of taxa as the abundance table. 
# There should be no empty (all zero) taxon vectors in the abundance table. 
# Even if you input your own correlation table, the persistence cutoff will be applied
use.custom.cors <- F

###################################################################
###################################################################
```

```{r Preparing the data for cohesion, eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE, results='hide'}
# Read in dataset
## Data should be in a matrix where each row is a sample. 
# Their example:
# b <- read.csv("your_path_here.csv", header = T, row.names = 1)

# But I have what I need already
IMOS_MAGS_drep99imos_95ANI_for_cohesion <- pMAGs_95ANI_phyloseq@otu_table
# Let's add the annotations also in row names
# renaming columns here so that I can identify the X and Y datasets
MAGs_annotations <- IMOS_MAGS_drep99imos_95ANI_for_cohesion
# getting names for taxa
MAGs_annotations_colnames <- left_join(otu_table(pMAGs_95ANI_phyloseq) %>%
                                    as.data.frame %>%
                                    rownames_to_column("OTU"),
                                  tax_table(pMAGs_95ANI_phyloseq) %>%
                                    as.data.frame %>%
                                    rownames_to_column("OTU")) %>%
  tidyr::unite(taxonomy, c(Order, Family, Genus, Species), sep = "; ") # Adding Taxonomy info
## Joining, by = "OTU"
MAGs_annotations_colnames <- MAGs_annotations_colnames %>% 
  dplyr::select("OTU", "taxonomy")
# Merging with the OTUs_biplot object
MAGs_annotations_names <- left_join(MAGs_annotations %>% 
                           as.data.frame() %>% 
                           rownames_to_column("OTU"),
                         MAGs_annotations_colnames) %>% 
 tidyr::unite(Annotations, c(OTU, taxonomy), sep = "_") %>% 
 column_to_rownames("Annotations")  # moving this as rowposing back into the right format

# Now computing relative abundances
MAGs_annotations_RA <- MAGs_annotations_names
for (i in 1:(ncol(MAGs_annotations_names))) {
  MAGs_annotations_RA[i] <- MAGs_annotations_RA[i] / sum(MAGs_annotations_RA[i]) 
}
# Checking if colSums sum to 1
colSums(MAGs_annotations_RA)
# Perfect!

# Now transposing, because they want samples in rows
b <- t(MAGs_annotations_RA)
# rowSums(b)

# ---------------------------------------------------------- #
# I am naming the final matrix 'b' as this is what they want #
# ---------------------------------------------------------- #

# ------------------------------------------------------------------------------- #
# This is not needed though as I will use their way to get pairwise correlations! #
# ------------------------------------------------------------------------------- #

# Read in custom correlation matrix, if desired. Must set "use.custom.cors" to TRUE
# if(use.custom.cors == T) {
#  custom.cor.mat <- read.csv("your_path_here.csv", header = T, row.names = 1)
#  custom.cor.mat <- as.matrix(custom.cor.mat)
#  #Check that correlation matrix and abundance matrix have the same dimension
#  print(dim(b)[2] == dim(custom.cor.mat)[2])
#}
```

```{r Formatting data for cohesion as suggested in the script, fig.cap="Histograms serve to double check that row sums equal 1 (relative abundances per sample). Looks good.", eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE}
# Suggested steps to re-format data. At the end of these steps, the data should be in a matrix "c" where there are no
# empty samples or blank taxon columns.

# --- 1 --- #
c <- as.matrix(b)
c <- c[rowSums(c) > 0, colSums(c) > 0]
# But this makes no difference for as as the data frame was already formatted accordingly

# --- 2 --- #
# Optionally re-order dataset to be in chronological order. Change date format for your data. 
#c <- c[order(as.Date(rownames(c), format = "%m/%d/%Y")), ]
# I commented this out, we don't have temporal data and doesn't make sense for the big dataset, but maybe yes for observatories

# --- 3 --- #
# Save total number of individuals in each sample in the original matrix. This will be 1 if data are in relative abundance, 
# but not if matrix c is count data
rowsums.orig <- rowSums(c)

# --- 4 --- #
# Based on persistence cutoff, define a cutoff for the number of zeroes allowed in a taxon's distribution
zero.cutoff <- ceiling(pers.cutoff * dim(c)[1])

# --- 5 --- #
# Remove taxa that are below the persistence cutoff
d <- c[ , apply(c, 2, zero) < (dim(c)[1]-zero.cutoff) ]
# Remove any samples that no longer have any individuals, due to removing taxa
d <- d[rowSums(d) > 0, ]
# Again, this didn't make any difference for us because we already removed lowly abundant MAGs (?)

# --- 6 --- #
#If using custom correlation matrix, need to remove rows/columns corresponding to the taxa below persistence cutoff
# if(use.custom.cors == T){
#  custom.cor.mat.sub <- custom.cor.mat[apply(c, 2, zero) < (dim(c)[1]-zero.cutoff), apply(c, 2, zero) < (dim(c)[1]-zero.cutoff)]
#}

# --- 7 --- #
# Create relative abundance matrix.  
rel.d <- d / rowsums.orig
# Optionally, check to see what proportion of the community is retained after cutting out taxa
hist(rowSums(rel.d))
# rowSums always sums to 1, that is good
```

```{r Computing observed and expected correlations, eval=FALSE, message = FALSE, warning=FALSE, echo=TRUE}
# Create observed correlation matrix
cor.mat.true <- cor(rel.d)

# Create vector to hold median otu-otu correlations for initial otu
med.tax.cors <- vector()

# Run this loop for the null model to get expected pairwise correlations
# Bypass null model if the option to input custom correlation matrix is TRUE
if(use.custom.cors == F) {
if(tax.shuffle) {
  for(which.taxon in 1:dim(rel.d)[2]){
    
    #create vector to hold correlations from every permutation for each single otu
    ## perm.cor.vec.mat stands for permuted correlations vector matrix
    perm.cor.vec.mat <- vector()
    
    for(i in 1:iter){
      #Create empty matrix of same dimension as rel.d
      perm.rel.d <- matrix(numeric(0), dim(rel.d)[1], dim(rel.d)[2])
      rownames(perm.rel.d) <- rownames(rel.d)
      colnames(perm.rel.d) <- colnames(rel.d)
      
      #For each otu
      for(j in 1:dim(rel.d)[2]){ 
        # Replace the original taxon vector with a permuted taxon vector
        perm.rel.d[, j ] <- sample(rel.d[ ,j ]) 
      }
      
      # Do not randomize focal column 
      perm.rel.d[, which.taxon] <- rel.d[ , which.taxon]
      
      # Calculate correlation matrix of permuted matrix
      cor.mat.null <- cor(perm.rel.d)
      
      # For each iteration, save the vector of null matrix correlations between focal taxon and other taxa
      perm.cor.vec.mat <- cbind(perm.cor.vec.mat, cor.mat.null[, which.taxon])
      
    }
    # Save the median correlations between the focal taxon and all other taxa  
    med.tax.cors <- cbind(med.tax.cors, apply(perm.cor.vec.mat, 1, median))
    
    # For large datasets, this can be helpful to know how long this loop will run
    if(which.taxon %% 20 == 0){print(which.taxon)}
  }
} else {
  for(which.taxon in 1:dim(rel.d)[2]){
    
    #create vector to hold correlations from every permutation for each single otu
    ## perm.cor.vec.mat stands for permuted correlations vector matrix
    perm.cor.vec.mat <- vector()
    
    for(i in 1:iter){
      #Create duplicate matrix to shuffle abundances
      perm.rel.d <- rel.d 
      
      #For each taxon
      for(j in 1:dim(rel.d)[1]){ 
        which.replace <- which(rel.d[j, ] > 0 ) 
        # if the focal taxon is greater than zero, take it out of the replacement vector, so the focal abundance stays the same
        which.replace.nonfocal <- which.replace[!(which.replace %in% which.taxon)]
        
        #Replace the original taxon vector with a vector where the values greater than 0 have been randomly permuted 
        perm.rel.d[j, which.replace.nonfocal] <- sample(rel.d[ j, which.replace.nonfocal]) 
      }

      # Calculate correlation matrix of permuted matrix
      cor.mat.null <- cor(perm.rel.d)
      
      # For each iteration, save the vector of null matrix correlations between focal taxon and other taxa
      perm.cor.vec.mat <- cbind(perm.cor.vec.mat, cor.mat.null[, which.taxon])
      
    }
    # Save the median correlations between the focal taxon and all other taxa  
    med.tax.cors <- cbind(med.tax.cors, apply(perm.cor.vec.mat, 1, median))
    
    # For large datasets, this can be helpful to know how long this loop will run
    if(which.taxon %% 20 == 0){print(which.taxon)}
  }
 }
}
```

```{r Computing Observed minus expected correlations, eval=FALSE, message = FALSE, warning=FALSE, echo=TRUE, results='hide'}
# Save observed minus expected correlations. Use custom correlations if use.custom.cors = TRUE
if(use.custom.cors == T) {
  obs.exp.cors.mat <- custom.cor.mat.sub
  } else {
    obs.exp.cors.mat <- cor.mat.true - med.tax.cors
  }
  
diag(obs.exp.cors.mat) <- 0
```

```{r Saving the cohesion and connectedness output, eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE, results='hide'}
#### 
#### Produce desired vectors of connectedness and cohesion 

# Calculate connectedness by averaging positive and negative observed - expected correlations
connectedness.pos <- apply(obs.exp.cors.mat, 2, pos.mean)
connectedness.neg <- apply(obs.exp.cors.mat, 2, neg.mean)

# Calculate cohesion by multiplying the relative abundance dataset by associated connectedness
cohesion.pos <- rel.d %*% connectedness.pos
cohesion.neg <- rel.d %*% connectedness.neg

####
#### Combine vectors into one list and print 
output <- list(connectedness.neg, connectedness.pos, cohesion.neg, cohesion.pos)
names(output) <- c("Negative Connectedness", "Positive Connectedness", "Negative Cohesion", "Positive Cohesion")
# print(output)
```

```{r Positive cohesion across transects, fig.cap="The positive cohesion between the sampling trips. The boxplots show inner quartiles and median positive cohesion on the y axis. A higher value indicates a prevalence of positive interactions in the microbial community. X-axis presents reef sampling transects. Higher positive cohesion for the sites sampled in the winter trip may suggest a prevalence of positive interactions (mutualism, co-occurrence due to metabolic exchange) in the winter when nutrients are depleted. But is negative cohesion higher during summer trips?", fig.height=4, fig.width=9, eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE}
# Df for positive cohesion
pos.cohesion_to_viz <- cohesion.pos %>%
  as.data.frame() %>%
  rownames_to_column("Sample_ID")
colnames(pos.cohesion_to_viz) <- c("Sample_ID", "Positive_cohesion")

# Df for negative cohesion
neg.cohesion_to_viz <- cohesion.neg %>%
  as.data.frame() %>%
  rownames_to_column("Sample_ID")
colnames(neg.cohesion_to_viz) <- c("Sample_ID", "Negative_cohesion")

# Merging both pos and neg cohesion
cohesion_to_viz <- left_join(pos.cohesion_to_viz, neg.cohesion_to_viz)
# Computing the ratio
cohesion_to_viz$Ratio_pos_neg <- abs(cohesion_to_viz$Positive_cohesion/cohesion_to_viz$Negative_cohesion)
# But removing Broomfield2
cohesion_to_viz <- filter(cohesion_to_viz, Sample_ID != "broomfield_2__BBG5503")

# Visualising now
left_join(cohesion_to_viz,
  sample_data(pMAGs_95ANI_phyloseq_clr) %>% 
    as.data.frame()) %>%
  ggplot() +
  geom_boxplot(aes(#x = Open_or_Closed_to_fishing,
                   y = Positive_cohesion, fill = Sampling_trip)) +
  facet_grid(~Sampling_trip) +
  ylab("Positive Cohesion") +
  scale_fill_manual(values = c("indianred", # Sampling trip 1
                "indianred4", # Sampling trip 2 
                "red3", # Sampling trip 3
                "slateblue") # Sampling trip 4
                ) +
  theme(axis.text.x = element_blank())
```

```{r Negative cohesion across transects, fig.cap="The negative cohesion between the sampling trips. The boxplots show inner quartiles and median negative cohesion (expressed as absolute value) on the y axis. A higher value indicates a prevalence of negative interactions in the microbial community. X-axis presents reef sampling transects. Higher negative cohesion for the sites sampled in the summer trips may suggest a potential increase of negative/mutually exclusive interactions (competition, predator/prey, pathogen/host, parasite/host, and etc.) in the summer trips when nutrients are elevated, potentially indicating that opportunistic microbes are competing for available nutrients that are elevated in the summer transects.", fig.height=4, fig.width=9, eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE}
# Visualising now
left_join(cohesion_to_viz,
  sample_data(pMAGs_95ANI_phyloseq_clr) %>% 
    as.data.frame()) %>%
  ggplot() +
  geom_boxplot(aes(#x = Open_or_Closed_to_fishing,
                   y = abs(Negative_cohesion), fill = Sampling_trip)) +
  facet_grid(~Sampling_trip) +
  ylab("Negative Cohesion (abs value)") +
  scale_fill_manual(values = c("indianred", # Sampling trip 1
                "indianred4", # Sampling trip 2 
                "red3", # Sampling trip 3
                "slateblue") # Sampling trip 4
                ) +
  theme(axis.text.x = element_blank())
```

```{r Positive to negative cohesion ratio across transects, fig.cap="The positive:negative cohesion ratio between the sampling trips. The boxplots show inner quartiles and median positive:negative cohesion (shown as an absolute value) on the y axis. A higher value indicates a prevalence of positive compared to negative interactions in the microbial community. X-axis presents reef sampling transects. Higher positive:negative cohesion for the sites sampled in the winter trip may suggest a prevalence of positive interactions (mutualism, co-occurrence due to metabolic exchange) in the winter when nutrients are depleted. In contrast, we see a potential increase of negative/mutually exclusive interactions (competition, predator/prey, pathogen/host, parasite/host, and etc.) in the summer trips when nutrients are elevated, potentially indicating that opportunistic microbes are competing for available nutrients that are elevated in the summer transects.", fig.height=4, fig.width=9, eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE}
# Visualising now
left_join(cohesion_to_viz,
  sample_data(pMAGs_95ANI_phyloseq_clr) %>% 
    as.data.frame()) %>%
  ggplot() +
  geom_boxplot(aes(#x = Open_or_Closed_to_fishing,
                   y = Ratio_pos_neg, fill = Sampling_trip)) +
  facet_grid(~Sampling_trip) +
  ylab("Positive:negative cohesion ratio") +
  scale_fill_manual(values = c("indianred", # Sampling trip 1
                "indianred4", # Sampling trip 2 
                "red3", # Sampling trip 3
                "slateblue") # Sampling trip 4
                ) +
  theme(axis.text.x = element_blank()) +
  theme_bw()
```

Are we also seeing these differences between reefs that are open and closed to fishing?

```{r Positive cohesion accros open and closed, fig.cap="The positive cohesion between no-take and take zones. The boxplots show inner quartiles and median positive cohesion on the y axis. A higher value indicates a prevalence of positive interactions in the microbial community. X-axis presents reef management zoning. Higher positive cohesion for the sites in no take zones may suggest a prevalence of positive interactions (mutualism, co-occurrence due to metabolic exchange) in protected reef sites.", fig.height=4, fig.width=6, eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE}
# Calculate median and SD for each group
cohesion_stats <- ddply(left_join(cohesion_to_viz,
  sample_data(pMAGs_95ANI_phyloseq_clr) %>% 
    as.data.frame()) %>% 
    column_to_rownames("Sample_ID") %>%
    dplyr::select("Positive_cohesion", "Negative_cohesion", "Ratio_pos_neg", "Open_or_Closed_to_fishing", "SECTOR_N_S"),
               .(Open_or_Closed_to_fishing),  # Specify the grouping variable
               summarize,
               median_Positive_cohesion = median(Positive_cohesion, na.rm = TRUE),
               SD_Positive_cohesion = sd(Positive_cohesion, na.rm = TRUE),
               median_Negative_cohesion = median(Negative_cohesion, na.rm = TRUE),
               SD_Negative_cohesion = sd(Negative_cohesion, na.rm = TRUE),
               median_Ratio_pos_neg = median(Ratio_pos_neg, na.rm = TRUE),
               SD_Ratio_pos_neg = sd(Ratio_pos_neg, na.rm = TRUE)
  )

# Visualising now
left_join(cohesion_to_viz,
  sample_data(pMAGs_95ANI_phyloseq_clr) %>% 
    as.data.frame()) %>%
  ggplot() +
  geom_boxplot(aes(x = Open_or_Closed_to_fishing,
                   y = Positive_cohesion, fill = Open_or_Closed_to_fishing)) +
        geom_jitter(aes(y = Positive_cohesion, 
                  x = Open_or_Closed_to_fishing 
#                  color = Overall_GroupContrib
),
              width = 0.2, # adjust width to control the spread of the points
              size = 1.2,   # adjust size for better visibility
              alpha = 0.5) + # adjust transparency if needed
    geom_text(data = cohesion_stats, 
            aes(x = Open_or_Closed_to_fishing, 
                y = median_Positive_cohesion + 0.1,  # Adjust position above the boxplot
                label = paste("Median:", round(median_Positive_cohesion, 2), "\nSD:", round(SD_Positive_cohesion, 2))),
            size = 5, 
            position = position_nudge(x = 0.1),  # Adjust for better placement if needed
            color = "black") +
#  facet_grid(~Open_or_Closed_to_fishing, scales = "free") +
  ylab("Positive Cohesion") +
  scale_fill_manual(values = c("seagreen3", # Closed
                              "steelblue4") # Open
                ) +
  theme_bw() +
  theme(axis.text.x = element_blank())
```

```{r Negative cohesion across open and closed, fig.cap="The negative cohesion between no-take and take zones. The boxplots show inner quartiles and median negative cohesion (as absolute value) on the y axis. A higher value indicates a prevalence of negative interactions in the microbial community. X-axis presents reef management zoning. Higher negative cohesion for the sites in take zones may suggest a prevalence of negative interactions (competition, predator/prey, pathogen/host, parasite/host, and etc.) in non-protected reef sites.", fig.height=4, fig.width=6, eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE}
# Visualising now
left_join(cohesion_to_viz,
  sample_data(pMAGs_95ANI_phyloseq_clr) %>% 
    as.data.frame()) %>%
  ggplot() +
  geom_boxplot(aes(x = Open_or_Closed_to_fishing,
                   y = abs(Negative_cohesion), fill = Open_or_Closed_to_fishing)) +
  geom_jitter(aes(y = abs(Negative_cohesion), 
                  x = Open_or_Closed_to_fishing 
#                  color = Overall_GroupContrib
),
              width = 0.2, # adjust width to control the spread of the points
              size = 1.2,   # adjust size for better visibility
              alpha = 0.5) + # adjust transparency if needed
  geom_text(data = cohesion_stats, 
            aes(x = Open_or_Closed_to_fishing, 
                y = abs(median_Negative_cohesion) + 0.02,  # Adjust position above the boxplot
                label = paste("Median:", round(abs(median_Negative_cohesion), 2), "\nSD:", round(abs(SD_Negative_cohesion), 2))),
            size = 5, 
            position = position_nudge(x = 0.1),  # Adjust for better placement if needed
            color = "black") +
#  facet_grid(~Open_or_Closed_to_fishing, scales = "free") +
  ylab("Negative Cohesion (abs value)") +
  scale_fill_manual(values = c("seagreen3", # Closed
                              "steelblue4") # Open
                ) +
    theme_bw() +
  theme(axis.text.x = element_blank())
```

```{r Positive to negative cohesion ratio across open and closed, fig.cap="The positive:negative cohesion ratio between reefs in different zoning areas. The boxplots show inner quartiles and median positive:negative cohesion (shown as an absolute value) on the y axis. A higher value indicates a prevalence of positive compared to negative interactions in the microbial community. X-axis presents reef zoning. Higher positive:negative cohesion for the sites in no-take zones may suggest a prevalence of positive interactions (mutualism, co-occurrence due to metabolic exchange) when fishing activity is prohibitted. In contrast, we see a potential increase of negative/mutually exclusive interactions (competition, predator/prey, pathogen/host, parasite/host, and etc.) in the take zones.", fig.height=3, fig.width=5, eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE}
# Define the custom shapes for each sector
sector_shapes <- c("CG" = 1,  # Filled circle
                   "PC" = 2,  # Filled triangle
                   "SW" = 6,  # Filled diamond
                   "CA" = 3,  # Filled square
                   "CB" = 7,  # Solid circle
                   "TO" = 5,   # Plus sign
                   "IN" = 4)   # Cross

# Define the custom colors for each sector
sector_colors <- c("CG" = "indianred",  # Trip 1
                   "PC" = "indianred",  # Trip 1
                   "SW" = "indianred4",  # Trip 2
                   "CA" = "red3",  # Trip 3
                   "CB" = "indianred4",  # Trip 2
                   "TO" = "slateblue",   # Trip 4
                   "IN" = "red3")   # Trip 3

# Let's visualise:
cohesion_pos_neg_boxplots <- left_join(cohesion_to_viz,
  sample_data(pMAGs_95ANI_phyloseq_clr) %>% 
    as.data.frame()) %>%
  ggplot() +
  geom_boxplot(aes(x = Open_or_Closed_to_fishing,
                   y = Ratio_pos_neg, fill = Open_or_Closed_to_fishing)) +
  geom_jitter(aes(y = Ratio_pos_neg, 
                  x = Open_or_Closed_to_fishing, 
                  shape = factor(SECTOR),  # Map SECTOR to shape
                  color = factor(SECTOR)), # Map SECTOR to color
              width = 0.2, # adjust width to control the spread of the points
              size = 2,   # adjust size for better visibility
              alpha = 0.7) + # adjust transparency (increased from 0.2 to 0.7 for better color visibility) +
  geom_text(data = cohesion_stats, 
            aes(x = Open_or_Closed_to_fishing, 
                y = median_Ratio_pos_neg + 0.5,  # Adjust position above the boxplot
                label = paste(round(median_Ratio_pos_neg, 2), "±", round(SD_Ratio_pos_neg, 2))),
            size = 5, 
            position = position_nudge(x = 0.1),  # Adjust for better placement if needed
            color = "black") +
  ylab("Positive/Negative Cohesion ratio") +
  scale_fill_manual(values = c("seagreen3", # Closed
                              "steelblue4") # Open
                ) +
  scale_shape_manual(values = sector_shapes) +  # Apply custom shapes based on SECTOR
  scale_color_manual(values = sector_colors) +  # Apply custom colors based on SECTOR
  theme_bw() +
  theme(axis.text.x = element_blank()) +
  guides(fill = "none") +  # Remove the legend for fill aesthetic
  # Wilcoxon rank sum test
  stat_pvalue_manual(left_join(cohesion_to_viz,
  sample_data(pMAGs_95ANI_phyloseq_clr) %>% 
    as.data.frame()) %>% 
                       pairwise_wilcox_test(Ratio_pos_neg ~ Open_or_Closed_to_fishing) %>% 
                       add_xy_position()
  )
```

Let's also try to partition this based on GBR sectors:

```{r Positive to negative cohesion ratio between open and closed reefs and within sectors, fig.cap="The positive:negative cohesion ratio between reefs in different zoning areas. The boxplots show inner quartiles and median positive:negative cohesion (shown as an absolute value) on the y axis. A higher value indicates a prevalence of positive compared to negative interactions in the microbial community. X-axis presents reef zoning. Higher positive:negative cohesion for the sites in no-take zones may suggest a prevalence of positive interactions (mutualism, co-occurrence due to metabolic exchange) when fishing activity is prohibitted. In contrast, we see a potential increase of negative/mutually exclusive interactions (competition, predator/prey, pathogen/host, parasite/host, and etc.) in the take zones.", fig.height=4, fig.width=11, eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE}
# Define the custom shapes for each sector
sector_shapes <- c("CG" = 1,  # Filled circle
                   "PC" = 2,  # Filled triangle
                   "SW" = 6,  # Filled diamond
                   "CA" = 3,  # Filled square
                   "CB" = 7,  # Solid circle
                   "TO" = 5,   # Plus sign
                   "IN" = 4)   # Cross

# Define the custom colors for each sector
sector_colors <- c("CG" = "indianred",  # Trip 1
                   "PC" = "indianred",  # Trip 1
                   "SW" = "indianred4",  # Trip 2
                   "CA" = "red3",  # Trip 3
                   "CB" = "indianred4",  # Trip 2
                   "TO" = "slateblue",   # Trip 4
                   "IN" = "red3")   # Trip 3

# Visualising now
left_join(cohesion_to_viz,
  sample_data(pMAGs_95ANI_phyloseq_clr) %>% 
    as.data.frame()) %>%
  ggplot() +
  geom_boxplot(aes(x = Open_or_Closed_to_fishing,
                   y = Ratio_pos_neg, fill = Open_or_Closed_to_fishing)) +
  geom_jitter(aes(y = Ratio_pos_neg, 
                  x = Open_or_Closed_to_fishing,
                  shape = factor(SECTOR),  # Map SECTOR to shape
                  color = factor(SECTOR)), # Map SECTOR to color
              width = 0.2, # adjust width to control the spread of the points
              size = 1.2,   # adjust size for better visibility
              alpha = 0.7) + # adjust transparency (increased for better color visibility)
  geom_text(data = cohesion_stats, 
            aes(x = Open_or_Closed_to_fishing, 
                y = median_Ratio_pos_neg + 0.02,  # Adjust position above the boxplot
                label = paste(round(median_Ratio_pos_neg, 2), "±", round(SD_Ratio_pos_neg, 2))),
            size = 5, 
            position = position_nudge(x = 0.1),  # Adjust for better placement if needed
            color = "black") +
  facet_wrap(~SECTOR_N_S, scales = "free", nrow = 2, ncol = 4) +
  ylab("Positive/Negative Cohesion ratio") +
  scale_fill_manual(values = c("seagreen3", # Closed
                              "steelblue4") # Open
                ) +
  scale_shape_manual(values = sector_shapes) +  # Apply custom shapes
  scale_color_manual(values = sector_colors) +  # Apply custom colors
  theme_bw() +
  theme(axis.text.x = element_blank()) # +
# Testing the significance with pairwise Wilcoxon rank sum tests
#  stat_pvalue_manual(left_join(cohesion_to_viz,
#  sample_data(pMAGs_95ANI_phyloseq_clr) %>% 
#    as.data.frame()) %>% 
#                       pairwise.wilcox.test(Ratio_pos_neg, SECTOR_N_S ~ Open_or_Closed_to_fishing) %>% 
#                       add_xy_position()
#  )
```

### Connectedness metrics for indicator pMAGs identified in MINT sPLS and MINT sPLS-DA

```{r Preparing the connectedness scores for plotting, eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE, results='hide'}
connectedness.barplots <- left_join(as.data.frame(connectedness.pos) %>% rownames_to_column("MAGs"),
                                    as.data.frame(connectedness.neg) %>% rownames_to_column("MAGs"))
connectedness.barplots$Connectedness_Ratio_neg_pos <- abs(connectedness.barplots$connectedness.neg/connectedness.barplots$connectedness.pos)
connectedness.barplots$Connectedness_Ratio_pos_neg <- abs(connectedness.barplots$connectedness.pos/connectedness.barplots$connectedness.neg)
# Checking what we got:
colnames(connectedness.barplots)
dim(connectedness.barplots)
```

```{r Barplots positive negative connectedness ratio for the 350 MINT sPLS indicators, fig.height=30, fig.width=6, eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE}
# Preparing the Connectedness values to merge with the dataframe on MINT sPLS indicators
connectedness.barplots_to_merge <- connectedness.barplots %>% 
  as.data.frame() %>%
#  rownames_to_column("MAGs") %>%
  tidyr::separate(., col = MAGs, into = c("OTU", "taxonomy"), sep = "_o__")# Separating OTUs and taxonomy

# Now pulling out the MAGs selected as indicators in MINT sPLS
pMAGs_connectedness.MINT_sPLS_indicators <- left_join(MINT_sPLS_CheckM_stats %>% 
                                                        dplyr::select("OTU", "Overall_GroupContrib"),
                                                      connectedness.barplots_to_merge,
                                                      )
# Plotting as barplots!
connectedness_pos_neg_barplots <- pMAGs_connectedness.MINT_sPLS_indicators %>% # five is indicator colors, 23 is genome size
#  unite(OTU, c(OTU, taxonomy), sep = "; ") %>% # Trying to add taxonomy here but then the ordering deosn't work...
  ggplot(aes(y=factor(OTU, level = unique(heatmap_data_OTU_order$OTU)), # ordering the same way as the MAGs are ordered in the loading plots
             x = Connectedness_Ratio_pos_neg,
             fill = Overall_GroupContrib)) +
  geom_bar(stat = "identity", show.legend = FALSE) +
    scale_fill_manual(values = c("seagreen3", # C for No-take zones
#                                 "darkgray", # Not_discriminative_in_MINT_sPLS-DA
                               "steelblue4")) + # O for Take zones
  labs(y = 'Indicator pMAGs95%ANI',
       x = "Positive/Negative Connectedness ratio",
       title = 'Positive/Negative Connectedness ratio',
       subtitle = 'Network - Entire dataset') +
      theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 12), legend.position = "NONE") +
  theme_bw() +
  scale_y_discrete(limits=rev)
```

```{r Figure 4 all barplots together, fig.height=12, fig.width=6, eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE, results='hide', fig.show='hide'}
patchwork::wrap_plots(Genome_size_barplots,
                      GC_content_barplots,
                      KEGG_completeness_barplots,
                      connectedness_pos_neg_barplots,
                      nrow = 4,
                      ncol = 1)
```

```{r Connectedness boxplots, fig.height=3, fig.width=3, eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE, results='hide', fig.show='hide'}
connectedness_pos_neg_boxplots <- ddply(pMAGs_connectedness.MINT_sPLS_indicators %>% 
                             column_to_rownames("OTU") %>% 
                             dplyr::select("Overall_GroupContrib", "Connectedness_Ratio_pos_neg"),
                           .(Overall_GroupContrib), # summarise based on the group of interest
                           summarise,
                           Median_Connectedness_Ratio_pos_neg = median(Connectedness_Ratio_pos_neg, na.rm = TRUE),
                           SD_Connectedness_Ratio_pos_neg = sd(Connectedness_Ratio_pos_neg, na.rm = TRUE))

# Plotting
Connectedness_pos_neg_boxplots <- pMAGs_connectedness.MINT_sPLS_indicators %>%   
  ggplot() +
  geom_boxplot(aes(y = Connectedness_Ratio_pos_neg,
                   x = Overall_GroupContrib,
                   fill = Overall_GroupContrib),
               show.legend = FALSE) + # just fill as in Trip 2
      geom_jitter(aes(y = Connectedness_Ratio_pos_neg, 
                  x = Overall_GroupContrib 
#                  color = Overall_GroupContrib
),
              width = 0.2, # adjust width to control the spread of the points
              size = 1.2,   # adjust size for better visibility
              alpha = 0.1) + # adjust transparency if needed
  geom_text(data = connectedness_pos_neg_boxplots, 
            aes(x = Overall_GroupContrib, 
                y = Median_Connectedness_Ratio_pos_neg + 0.1, # Adjust y position for visibility
                label = paste(round(Median_Connectedness_Ratio_pos_neg, 2), "±", round(SD_Connectedness_Ratio_pos_neg, 2))),
            color = "black", 
            size = 4.5, 
            vjust = 0) + # Adjust vertical justification as needed
#  facet_grid(~Sampling_trip) +
  labs(title="Pos/Neg Connectedness ratio",
       y="Pos/Neg Connectedness ratio",
       x="Reef Zoning Status") +
    scale_fill_manual(values = c("seagreen3", # C for No-take zones
#                                 "darkgray", # Not_discriminative_in_MINT_sPLS-DA
                               "steelblue4")) + # O for Take zones
  scale_y_continuous(limits = c(0, 5)) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 12), legend.position = "none") +
  stat_pvalue_manual(pMAGs_connectedness.MINT_sPLS_indicators %>% 
                       pairwise_wilcox_test(Connectedness_Ratio_pos_neg ~ Overall_GroupContrib) %>%
                       add_xy_position())
```


```{r Figure 4 all boxplots together, fig.height=15, fig.width=5, eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE}
patchwork::wrap_plots(genome_size_boxplots,
                      GC_boxplots,
                      KEGG_completeness_boxplots,
                      Connectedness_pos_neg_boxplots,
                      cohesion_pos_neg_boxplots,
                      nrow = 5,
                      ncol = 1)
```

### Cohesion metric within GBR sectors

As the cohesion metric was computed in Hernandez et al. (2021) for each of their subnetworks (i.e. for each soil type), I want to test the same now for each of the GBR sectors. This is important also as the analysis is then better connected to my mixOmics pipeline (and the LOGOCV logic from MINT).

I will only focus on the Pos-Neg ratio in this analysis.

```{r Subsetting the rel.d object within trips, eval=TRUE, warning=FALSE, message=FALSE, echo=TRUE}
### I already made an R object (rel.d) that has the relative abundances - now just need to split based on GBR sectors
# Let's print the sector names
unique(pMAGs_95ANI_phyloseq_clr@sam_data$SECTOR_N_S)
# And now partitioning the data per each of the 7 sectors:

# 01_Cape_Grenville
rel.d.CG <- rel.d[row.names(rel.d) %in% rownames(pMAGs_95ANI_phyloseq_clr@sam_data)[
  pMAGs_95ANI_phyloseq_clr@sam_data$SECTOR_N_S == "01_Cape_Grenville"
], ]
rowSums(rel.d.CG) # double checking that is sums up to 1

# 02_Princess_Charlotte_bay
rel.d.PC <- rel.d[row.names(rel.d) %in% rownames(pMAGs_95ANI_phyloseq_clr@sam_data)[
  pMAGs_95ANI_phyloseq_clr@sam_data$SECTOR_N_S == "02_Princess_Charlotte_bay"
], ]
rowSums(rel.d.PC)
# 03_Cairns
rel.d.CA <- rel.d[row.names(rel.d) %in% rownames(pMAGs_95ANI_phyloseq_clr@sam_data)[
  pMAGs_95ANI_phyloseq_clr@sam_data$SECTOR_N_S == "03_Cairns"
], ]
rowSums(rel.d.CA)
# 04_Innisfail
rel.d.IN <- rel.d[row.names(rel.d) %in% rownames(pMAGs_95ANI_phyloseq_clr@sam_data)[
  pMAGs_95ANI_phyloseq_clr@sam_data$SECTOR_N_S == "04_Innisfail"
], ]
rowSums(rel.d.IN)
# 05_Townsville
rel.d.TO <- rel.d[row.names(rel.d) %in% rownames(pMAGs_95ANI_phyloseq_clr@sam_data)[
  pMAGs_95ANI_phyloseq_clr@sam_data$SECTOR_N_S == "05_Townsville"
], ]
rowSums(rel.d.TO)
# 06_Swains
rel.d.SW <- rel.d[row.names(rel.d) %in% rownames(pMAGs_95ANI_phyloseq_clr@sam_data)[
  pMAGs_95ANI_phyloseq_clr@sam_data$SECTOR_N_S == "06_Swains"
], ]
rowSums(rel.d.SW)
# 07_Capricorn_Bunker
rel.d.CB <- rel.d[row.names(rel.d) %in% rownames(pMAGs_95ANI_phyloseq_clr@sam_data)[
  pMAGs_95ANI_phyloseq_clr@sam_data$SECTOR_N_S == "07_Capricorn_Bunker"
], ]
rowSums(rel.d.CB)
```

```{r Computing observed and expected correlations within sector CG, eval=FALSE, message = FALSE, warning=FALSE, echo=TRUE}
# Create observed correlation matrix
cor.mat.true.CG <- cor(rel.d.CG)

# Create vector to hold median otu-otu correlations for initial otu
med.tax.cors.CG <- vector()

# Run this loop for the null model to get expected pairwise correlations
# Bypass null model if the option to input custom correlation matrix is TRUE
if(use.custom.cors == F) {
if(tax.shuffle) {
  for(which.taxon in 1:dim(rel.d.CG)[2]){
    
    #create vector to hold correlations from every permutation for each single otu
    ## perm.cor.vec.mat stands for permuted correlations vector matrix
    perm.cor.vec.mat.CG <- vector()
    
    for(i in 1:iter){
      #Create empty matrix of same dimension as rel.d
      perm.rel.d.CG <- matrix(numeric(0), dim(rel.d.CG)[1], dim(rel.d.CG)[2])
      rownames(perm.rel.d.CG) <- rownames(rel.d.CG)
      colnames(perm.rel.d.CG) <- colnames(rel.d.CG)
      
      #For each otu
      for(j in 1:dim(rel.d.CG)[2]){ 
        # Replace the original taxon vector with a permuted taxon vector
        perm.rel.d.CG[, j ] <- sample(rel.d.CG[ ,j ]) 
      }
      
      # Do not randomize focal column 
      perm.rel.d.CG[, which.taxon] <- rel.d.CG[ , which.taxon]
      
      # Calculate correlation matrix of permuted matrix
      cor.mat.null.CG <- cor(perm.rel.d.CG)
      
      # For each iteration, save the vector of null matrix correlations between focal taxon and other taxa
      perm.cor.vec.mat.CG <- cbind(perm.cor.vec.mat.CG, cor.mat.null.CG[, which.taxon])
      
    }
    # Save the median correlations between the focal taxon and all other taxa  
    med.tax.cors.CG <- cbind(med.tax.cors.CG, apply(perm.cor.vec.mat.CG, 1, median))
    
    # For large datasets, this can be helpful to know how long this loop will run
    if(which.taxon %% 20 == 0){print(which.taxon)}
  }
} else {
  for(which.taxon in 1:dim(rel.d.CG)[2]){
    
    #create vector to hold correlations from every permutation for each single otu
    ## perm.cor.vec.mat stands for permuted correlations vector matrix
    perm.cor.vec.mat.CG <- vector()
    
    for(i in 1:iter){
      #Create duplicate matrix to shuffle abundances
      perm.rel.d.CG <- rel.d.CG 
      
      #For each taxon
      for(j in 1:dim(rel.d.CG)[1]){ 
        which.replace <- which(rel.d.CG[j, ] > 0 ) 
        # if the focal taxon is greater than zero, take it out of the replacement vector, so the focal abundance stays the same
        which.replace.nonfocal <- which.replace[!(which.replace %in% which.taxon)]
        
        #Replace the original taxon vector with a vector where the values greater than 0 have been randomly permuted 
        perm.rel.d.CG[j, which.replace.nonfocal] <- sample(rel.d.CG[ j, which.replace.nonfocal]) 
      }

      # Calculate correlation matrix of permuted matrix
      cor.mat.null.CG <- cor(perm.rel.d.CG)
      
      # For each iteration, save the vector of null matrix correlations between focal taxon and other taxa
      perm.cor.vec.mat.CG <- cbind(perm.cor.vec.mat.CG, cor.mat.null.CG[, which.taxon])
      
    }
    # Save the median correlations between the focal taxon and all other taxa  
    med.tax.cors.CG <- cbind(med.tax.cors.CG, apply(perm.cor.vec.mat.CG, 1, median))
    
    # For large datasets, this can be helpful to know how long this loop will run
    if(which.taxon %% 20 == 0){print(which.taxon)}
  }
 }
}
```

```{r CG - Computing Observed minus expected correlations, eval=FALSE, message = FALSE, warning=FALSE, echo=TRUE, results='hide'}
# Save observed minus expected correlations. Use custom correlations if use.custom.cors = TRUE
if(use.custom.cors == T) {
  obs.exp.cors.mat <- custom.cor.mat.sub
  } else {
    obs.exp.cors.mat.CG <- cor.mat.true.CG - med.tax.cors.CG
  }
  
diag(obs.exp.cors.mat.CG) <- 0
```

```{r CG - Saving the cohesion and connectedness output, eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE, results='hide'}
#### 
#### Produce desired vectors of connectedness and cohesion 

# Calculate connectedness by averaging positive and negative observed - expected correlations
connectedness.pos.CG <- apply(obs.exp.cors.mat.CG, 2, pos.mean)
connectedness.neg.CG <- apply(obs.exp.cors.mat.CG, 2, neg.mean)

# Calculate cohesion by multiplying the relative abundance dataset by associated connectedness
cohesion.pos.CG <- rel.d.CG %*% connectedness.pos.CG
cohesion.neg.CG <- rel.d.CG %*% connectedness.neg.CG

####
#### Combine vectors into one list and print 
output.CG <- list(connectedness.neg.CG, connectedness.pos.CG, cohesion.neg.CG, cohesion.pos.CG)
names(output.CG) <- c("Negative Connectedness", "Positive Connectedness", "Negative Cohesion", "Positive Cohesion")
# print(output.CG)
```

```{r CG Positive to negative cohesion ratio within Cape Grenville sector, fig.cap="The positive:negative cohesion ratio computed within Cape Grenville sector. The boxplots show inner quartiles and median positive:negative cohesion (shown as an absolute value) on the y axis. A higher value indicates a prevalence of positive compared to negative interactions in the microbial community. X-axis shows the reefs that are open or closed to fishing.", fig.height=3, fig.width=3, eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE, fig.show='hide'}
# Df for positive cohesion
pos.cohesion_to_viz.CG <- cohesion.pos.CG %>%
  as.data.frame() %>%
  rownames_to_column("Sample_ID")
colnames(pos.cohesion_to_viz.CG) <- c("Sample_ID", "Positive_cohesion")

# Df for negative cohesion
neg.cohesion_to_viz.CG <- cohesion.neg.CG %>%
  as.data.frame() %>%
  rownames_to_column("Sample_ID")
colnames(neg.cohesion_to_viz.CG) <- c("Sample_ID", "Negative_cohesion")

# Merging both pos and neg cohesion
cohesion_to_viz.CG <- left_join(pos.cohesion_to_viz.CG, neg.cohesion_to_viz.CG)
# Computing the ratio
cohesion_to_viz.CG$Ratio_pos_neg <- abs(cohesion_to_viz.CG$Positive_cohesion/cohesion_to_viz.CG$Negative_cohesion)
cohesion_to_viz.CG$Ratio_neg_pos <- abs(cohesion_to_viz.CG$Negative_cohesion/cohesion_to_viz.CG$Positive_cohesion)

### Getting the stats now
# Calculate median and SD for each group
cohesion_stats.CG <- ddply(left_join(cohesion_to_viz.CG,
  sample_data(pMAGs_95ANI_phyloseq_clr) %>% 
    as.data.frame()) %>% 
    column_to_rownames("Sample_ID") %>%
    dplyr::select("Positive_cohesion", "Negative_cohesion", "Ratio_pos_neg", "Open_or_Closed_to_fishing"),
               .(Open_or_Closed_to_fishing),  # Specify the grouping variable
               summarize,
               median_Positive_cohesion = median(Positive_cohesion, na.rm = TRUE),
               SD_Positive_cohesion = sd(Positive_cohesion, na.rm = TRUE),
               median_Negative_cohesion = median(Negative_cohesion, na.rm = TRUE),
               SD_Negative_cohesion = sd(Negative_cohesion, na.rm = TRUE),
               median_Ratio_pos_neg = median(Ratio_pos_neg, na.rm = TRUE),
               SD_Ratio_pos_neg = sd(Ratio_pos_neg, na.rm = TRUE)
  )

# Perform pairwise Wilcoxon tests and get the results
Wilcoxon.cohesion_stats.CG <- left_join(cohesion_to_viz.CG, 
                            sample_data(pMAGs_95ANI_phyloseq_clr) %>% 
                              as.data.frame()) %>%
  pairwise_wilcox_test(Ratio_pos_neg ~ Open_or_Closed_to_fishing)

# Extract the W-statistic and p-values, and format them for plotting
Wilcoxon.cohesion_stats_text.CG <- Wilcoxon.cohesion_stats.CG %>%
  mutate(
    stat_label = paste("W =", round(statistic, 2), "\np =", round(p, 3)),
    y.position = max(cohesion_to_viz.CG$Ratio_pos_neg) + 0.1  # Position above the boxplots
  )

# Visualising now
cohesion.boxplots.CG <- left_join(cohesion_to_viz.CG,
  sample_data(pMAGs_95ANI_phyloseq_clr) %>% 
    as.data.frame()) %>% 
  ggplot() +
  geom_boxplot(aes(x = Open_or_Closed_to_fishing,
                   y = Ratio_pos_neg, fill = Open_or_Closed_to_fishing)) +
        geom_jitter(aes(y = Ratio_pos_neg, 
                  x = Open_or_Closed_to_fishing 
#                  color = Overall_GroupContrib
),
              width = 0.2, # adjust width to control the spread of the points
              size = 1.2,   # adjust size for better visibility
              alpha = 0.5) + # adjust transparency if needed
    geom_text(data = cohesion_stats.CG, 
            aes(x = Open_or_Closed_to_fishing, 
                y = median_Ratio_pos_neg + 0.1,  # Adjust position above the boxplot
                label = paste("Median:", round(median_Ratio_pos_neg, 2), "\nSD:", round(SD_Ratio_pos_neg, 2))),
            size = 5, 
            position = position_nudge(x = 0.1),  # Adjust for better placement if needed
            color = "black") +
  geom_text(data = Wilcoxon.cohesion_stats.CG, 
            aes(x = group1, 
                y = 1,  # Adjust position to always be when y = 1, I will modify this later in Inkscape
                label = paste("W:", statistic, "\np-value adj:", p.adj)),
            size = 5, 
            color = "black") +
  facet_wrap(~SECTOR_N_S, scales = "free", nrow = 2, ncol = 4) +
  ylab("Positive/Negative Cohesion ratio") +
  scale_fill_manual(values = c("seagreen3", # Closed
                              "steelblue4") # Open
                ) +
  theme_bw() +
  theme(axis.text.x = element_blank(),
        legend.position = "none") +
stat_pvalue_manual(left_join(cohesion_to_viz.CG,
  sample_data(pMAGs_95ANI_phyloseq_clr) %>% 
    as.data.frame()) %>% 
                     pairwise_wilcox_test(Ratio_pos_neg ~ Open_or_Closed_to_fishing) %>%
                       add_xy_position())
cohesion.boxplots.CG
```

Now within the sector Princess Charlotte bay

```{r Computing observed and expected correlations within sector PC, eval=FALSE, message = FALSE, warning=FALSE, echo=TRUE}
# Create observed correlation matrix
cor.mat.true.PC <- cor(rel.d.PC)

# Create vector to hold median otu-otu correlations for initial otu
med.tax.cors.PC <- vector()

# Run this loop for the null model to get expected pairwise correlations
# Bypass null model if the option to input custom correlation matrix is TRUE
if(use.custom.cors == F) {
if(tax.shuffle) {
  for(which.taxon in 1:dim(rel.d.PC)[2]){
    
    #create vector to hold correlations from every permutation for each single otu
    ## perm.cor.vec.mat stands for permuted correlations vector matrix
    perm.cor.vec.mat.PC <- vector()
    
    for(i in 1:iter){
      #Create empty matrix of same dimension as rel.d
      perm.rel.d.PC <- matrix(numeric(0), dim(rel.d.PC)[1], dim(rel.d.PC)[2])
      rownames(perm.rel.d.PC) <- rownames(rel.d.PC)
      colnames(perm.rel.d.PC) <- colnames(rel.d.PC)
      
      #For each otu
      for(j in 1:dim(rel.d.PC)[2]){ 
        # Replace the original taxon vector with a permuted taxon vector
        perm.rel.d.PC[, j ] <- sample(rel.d.PC[ ,j ]) 
      }
      
      # Do not randomize focal column 
      perm.rel.d.PC[, which.taxon] <- rel.d.PC[ , which.taxon]
      
      # Calculate correlation matrix of permuted matrix
      cor.mat.null.PC <- cor(perm.rel.d.PC)
      
      # For each iteration, save the vector of null matrix correlations between focal taxon and other taxa
      perm.cor.vec.mat.PC <- cbind(perm.cor.vec.mat.PC, cor.mat.null.PC[, which.taxon])
      
    }
    # Save the median correlations between the focal taxon and all other taxa  
    med.tax.cors.PC <- cbind(med.tax.cors.PC, apply(perm.cor.vec.mat.PC, 1, median))
    
    # For large datasets, this can be helpful to know how long this loop will run
    if(which.taxon %% 20 == 0){print(which.taxon)}
  }
} else {
  for(which.taxon in 1:dim(rel.d.PC)[2]){
    
    #create vector to hold correlations from every permutation for each single otu
    ## perm.cor.vec.mat stands for permuted correlations vector matrix
    perm.cor.vec.mat.PC <- vector()
    
    for(i in 1:iter){
      #Create duplicate matrix to shuffle abundances
      perm.rel.d.PC <- rel.d.PC 
      
      #For each taxon
      for(j in 1:dim(rel.d.PC)[1]){ 
        which.replace <- which(rel.d.PC[j, ] > 0 ) 
        # if the focal taxon is greater than zero, take it out of the replacement vector, so the focal abundance stays the same
        which.replace.nonfocal <- which.replace[!(which.replace %in% which.taxon)]
        
        #Replace the original taxon vector with a vector where the values greater than 0 have been randomly permuted 
        perm.rel.d.PC[j, which.replace.nonfocal] <- sample(rel.d.PC[ j, which.replace.nonfocal]) 
      }

      # Calculate correlation matrix of permuted matrix
      cor.mat.null.PC <- cor(perm.rel.d.PC)
      
      # For each iteration, save the vector of null matrix correlations between focal taxon and other taxa
      perm.cor.vec.mat.PC <- cbind(perm.cor.vec.mat.PC, cor.mat.null.PC[, which.taxon])
      
    }
    # Save the median correlations between the focal taxon and all other taxa  
    med.tax.cors.PC <- cbind(med.tax.cors.PC, apply(perm.cor.vec.mat.PC, 1, median))
    
    # For large datasets, this can be helpful to know how long this loop will run
    if(which.taxon %% 20 == 0){print(which.taxon)}
  }
 }
}
```

```{r PC - Computing Observed minus expected correlations, eval=FALSE, message = FALSE, warning=FALSE, echo=TRUE, results='hide'}
# Save observed minus expected correlations. Use custom correlations if use.custom.cors = TRUE
if(use.custom.cors == T) {
  obs.exp.cors.mat <- custom.cor.mat.sub
  } else {
    obs.exp.cors.mat.PC <- cor.mat.true.PC - med.tax.cors.PC
  }
  
diag(obs.exp.cors.mat.PC) <- 0
```

```{r PC - Saving the cohesion and connectedness output, eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE, results='hide'}
#### 
#### Produce desired vectors of connectedness and cohesion 

# Calculate connectedness by averaging positive and negative observed - expected correlations
connectedness.pos.PC <- apply(obs.exp.cors.mat.PC, 2, pos.mean)
connectedness.neg.PC <- apply(obs.exp.cors.mat.PC, 2, neg.mean)

# Calculate cohesion by multiplying the relative abundance dataset by associated connectedness
cohesion.pos.PC <- rel.d.PC %*% connectedness.pos.PC
cohesion.neg.PC <- rel.d.PC %*% connectedness.neg.PC

####
#### Combine vectors into one list and print 
output.PC <- list(connectedness.neg.PC, connectedness.pos.PC, cohesion.neg.PC, cohesion.pos.PC)
names(output.PC) <- c("Negative Connectedness", "Positive Connectedness", "Negative Cohesion", "Positive Cohesion")
# print(output.PC)
```

```{r PC Positive to negative cohesion ratio within Princess Charlotte bay sector, fig.cap="The positive:negative cohesion ratio computed within Cape Grenville sector. The boxplots show inner quartiles and median positive:negative cohesion (shown as an absolute value) on the y axis. A higher value indicates a prevalence of positive compared to negative interactions in the microbial community. X-axis shows the reefs that are open or closed to fishing.", fig.height=3, fig.width=3, eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE, fig.show='hide'}
# Df for positive cohesion
pos.cohesion_to_viz.PC <- cohesion.pos.PC %>%
  as.data.frame() %>%
  rownames_to_column("Sample_ID")
colnames(pos.cohesion_to_viz.PC) <- c("Sample_ID", "Positive_cohesion")

# Df for negative cohesion
neg.cohesion_to_viz.PC <- cohesion.neg.PC %>%
  as.data.frame() %>%
  rownames_to_column("Sample_ID")
colnames(neg.cohesion_to_viz.PC) <- c("Sample_ID", "Negative_cohesion")

# Merging both pos and neg cohesion
cohesion_to_viz.PC <- left_join(pos.cohesion_to_viz.PC, neg.cohesion_to_viz.PC)
# Computing the ratio
cohesion_to_viz.PC$Ratio_pos_neg <- abs(cohesion_to_viz.PC$Positive_cohesion/cohesion_to_viz.PC$Negative_cohesion)
cohesion_to_viz.PC$Ratio_neg_pos <- abs(cohesion_to_viz.PC$Negative_cohesion/cohesion_to_viz.PC$Positive_cohesion)

### Getting the stats now
# Calculate median and SD for each group
cohesion_stats.PC <- ddply(left_join(cohesion_to_viz.PC,
  sample_data(pMAGs_95ANI_phyloseq_clr) %>% 
    as.data.frame()) %>% 
    column_to_rownames("Sample_ID") %>%
    dplyr::select("Positive_cohesion", "Negative_cohesion", "Ratio_pos_neg", "Open_or_Closed_to_fishing"),
               .(Open_or_Closed_to_fishing),  # Specify the grouping variable
               summarize,
               median_Positive_cohesion = median(Positive_cohesion, na.rm = TRUE),
               SD_Positive_cohesion = sd(Positive_cohesion, na.rm = TRUE),
               median_Negative_cohesion = median(Negative_cohesion, na.rm = TRUE),
               SD_Negative_cohesion = sd(Negative_cohesion, na.rm = TRUE),
               median_Ratio_pos_neg = median(Ratio_pos_neg, na.rm = TRUE),
               SD_Ratio_pos_neg = sd(Ratio_pos_neg, na.rm = TRUE)
  )

# Perform pairwise Wilcoxon tests and get the results
Wilcoxon.cohesion_stats.PC <- left_join(cohesion_to_viz.PC, 
                            sample_data(pMAGs_95ANI_phyloseq_clr) %>% 
                              as.data.frame()) %>%
  pairwise_wilcox_test(Ratio_pos_neg ~ Open_or_Closed_to_fishing)

# Extract the W-statistic and p-values, and format them for plotting
Wilcoxon.cohesion_stats_text.PC <- Wilcoxon.cohesion_stats.PC %>%
  mutate(
    stat_label = paste("W =", round(statistic, 2), "\np =", round(p, 3)),
    y.position = max(cohesion_to_viz.PC$Ratio_pos_neg) + 0.1  # Position above the boxplots
  )

# Visualising now
cohesion.boxplots.PC <- left_join(cohesion_to_viz.PC,
  sample_data(pMAGs_95ANI_phyloseq_clr) %>% 
    as.data.frame()) %>% 
  ggplot() +
  geom_boxplot(aes(x = Open_or_Closed_to_fishing,
                   y = Ratio_pos_neg, fill = Open_or_Closed_to_fishing)) +
        geom_jitter(aes(y = Ratio_pos_neg, 
                  x = Open_or_Closed_to_fishing 
#                  color = Overall_GroupContrib
),
              width = 0.2, # adjust width to control the spread of the points
              size = 1.2,   # adjust size for better visibility
              alpha = 0.5) + # adjust transparency if needed
    geom_text(data = cohesion_stats.PC, 
            aes(x = Open_or_Closed_to_fishing, 
                y = median_Ratio_pos_neg + 0.1,  # Adjust position above the boxplot
                label = paste("Median:", round(median_Ratio_pos_neg, 2), "\nSD:", round(SD_Ratio_pos_neg, 2))),
            size = 5, 
            position = position_nudge(x = 0.1),  # Adjust for better placement if needed
            color = "black") +
  geom_text(data = Wilcoxon.cohesion_stats.PC, 
            aes(x = group1, 
                y = 1,  # Adjust position to always be when y = 1, I will modify this later in Inkscape
                label = paste("W:", statistic, "\np-value adj:", p.adj)),
            size = 5, 
            color = "black") +
  facet_wrap(~SECTOR_N_S, scales = "free", nrow = 2, ncol = 4) +
  ylab("Positive/Negative Cohesion ratio") +
  scale_fill_manual(values = c("seagreen3", # Closed
                              "steelblue4") # Open
                ) +
  theme_bw() +
  theme(axis.text.x = element_blank(),
        legend.position = "none") +
stat_pvalue_manual(left_join(cohesion_to_viz.PC,
  sample_data(pMAGs_95ANI_phyloseq_clr) %>% 
    as.data.frame()) %>% 
                     pairwise_wilcox_test(Ratio_pos_neg ~ Open_or_Closed_to_fishing) %>%
                       add_xy_position())
cohesion.boxplots.PC
```

Now within the Cairns sector

```{r Computing observed and expected correlations within sector CA, eval=FALSE, message = FALSE, warning=FALSE, echo=TRUE}
# Create observed correlation matrix
cor.mat.true.CA <- cor(rel.d.CA)

# Create vector to hold median otu-otu correlations for initial otu
med.tax.cors.CA <- vector()

# Run this loop for the null model to get expected pairwise correlations
# Bypass null model if the option to input custom correlation matrix is TRUE
if(use.custom.cors == F) {
if(tax.shuffle) {
  for(which.taxon in 1:dim(rel.d.CA)[2]){
    
    #create vector to hold correlations from every permutation for each single otu
    ## perm.cor.vec.mat stands for permuted correlations vector matrix
    perm.cor.vec.mat.CA <- vector()
    
    for(i in 1:iter){
      #Create empty matrix of same dimension as rel.d
      perm.rel.d.CA <- matrix(numeric(0), dim(rel.d.CA)[1], dim(rel.d.CA)[2])
      rownames(perm.rel.d.CA) <- rownames(rel.d.CA)
      colnames(perm.rel.d.CA) <- colnames(rel.d.CA)
      
      #For each otu
      for(j in 1:dim(rel.d.CA)[2]){ 
        # Replace the original taxon vector with a permuted taxon vector
        perm.rel.d.CA[, j ] <- sample(rel.d.CA[ ,j ]) 
      }
      
      # Do not randomize focal column 
      perm.rel.d.CA[, which.taxon] <- rel.d.CA[ , which.taxon]
      
      # Calculate correlation matrix of permuted matrix
      cor.mat.null.CA <- cor(perm.rel.d.CA)
      
      # For each iteration, save the vector of null matrix correlations between focal taxon and other taxa
      perm.cor.vec.mat.CA <- cbind(perm.cor.vec.mat.CA, cor.mat.null.CA[, which.taxon])
      
    }
    # Save the median correlations between the focal taxon and all other taxa  
    med.tax.cors.CA <- cbind(med.tax.cors.CA, apply(perm.cor.vec.mat.CA, 1, median))
    
    # For large datasets, this can be helpful to know how long this loop will run
    if(which.taxon %% 20 == 0){print(which.taxon)}
  }
} else {
  for(which.taxon in 1:dim(rel.d.CA)[2]){
    
    #create vector to hold correlations from every permutation for each single otu
    ## perm.cor.vec.mat stands for permuted correlations vector matrix
    perm.cor.vec.mat.CA <- vector()
    
    for(i in 1:iter){
      #Create duplicate matrix to shuffle abundances
      perm.rel.d.CA <- rel.d.CA 
      
      #For each taxon
      for(j in 1:dim(rel.d.CA)[1]){ 
        which.replace <- which(rel.d.CA[j, ] > 0 ) 
        # if the focal taxon is greater than zero, take it out of the replacement vector, so the focal abundance stays the same
        which.replace.nonfocal <- which.replace[!(which.replace %in% which.taxon)]
        
        #Replace the original taxon vector with a vector where the values greater than 0 have been randomly permuted 
        perm.rel.d.CA[j, which.replace.nonfocal] <- sample(rel.d.CA[ j, which.replace.nonfocal]) 
      }

      # Calculate correlation matrix of permuted matrix
      cor.mat.null.CA <- cor(perm.rel.d.CA)
      
      # For each iteration, save the vector of null matrix correlations between focal taxon and other taxa
      perm.cor.vec.mat.CA <- cbind(perm.cor.vec.mat.CA, cor.mat.null.CA[, which.taxon])
      
    }
    # Save the median correlations between the focal taxon and all other taxa  
    med.tax.cors.CA <- cbind(med.tax.cors.CA, apply(perm.cor.vec.mat.CA, 1, median))
    
    # For large datasets, this can be helpful to know how long this loop will run
    if(which.taxon %% 20 == 0){print(which.taxon)}
  }
 }
}
```

```{r CA - Computing Observed minus expected correlations, eval=FALSE, message = FALSE, warning=FALSE, echo=TRUE, results='hide'}
# Save observed minus expected correlations. Use custom correlations if use.custom.cors = TRUE
if(use.custom.cors == T) {
  obs.exp.cors.mat <- custom.cor.mat.sub
  } else {
    obs.exp.cors.mat.CA <- cor.mat.true.CA - med.tax.cors.CA
  }
  
diag(obs.exp.cors.mat.CA) <- 0
```

```{r CA - Saving the cohesion and connectedness output, eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE, results='hide'}
#### 
#### Produce desired vectors of connectedness and cohesion 

# Calculate connectedness by averaging positive and negative observed - expected correlations
connectedness.pos.CA <- apply(obs.exp.cors.mat.CA, 2, pos.mean)
connectedness.neg.CA <- apply(obs.exp.cors.mat.CA, 2, neg.mean)

# Calculate cohesion by multiplying the relative abundance dataset by associated connectedness
cohesion.pos.CA <- rel.d.CA %*% connectedness.pos.CA
cohesion.neg.CA <- rel.d.CA %*% connectedness.neg.CA

####
#### Combine vectors into one list and print 
output.CA <- list(connectedness.neg.CA, connectedness.pos.CA, cohesion.neg.CA, cohesion.pos.CA)
names(output.CA) <- c("Negative Connectedness", "Positive Connectedness", "Negative Cohesion", "Positive Cohesion")
# print(output.CA)
```

```{r CA Positive to negative cohesion ratio within the Cairns sector, fig.cap="The positive:negative cohesion ratio computed within the Cairns sector. The boxplots show inner quartiles and median positive:negative cohesion (shown as an absolute value) on the y axis. A higher value indicates a prevalence of positive compared to negative interactions in the microbial community. X-axis shows the reefs that are open or closed to fishing.", fig.height=3, fig.width=3, eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE, fig.show='hide'}
# Df for positive cohesion
pos.cohesion_to_viz.CA <- cohesion.pos.CA %>%
  as.data.frame() %>%
  rownames_to_column("Sample_ID")
colnames(pos.cohesion_to_viz.CA) <- c("Sample_ID", "Positive_cohesion")

# Df for negative cohesion
neg.cohesion_to_viz.CA <- cohesion.neg.CA %>%
  as.data.frame() %>%
  rownames_to_column("Sample_ID")
colnames(neg.cohesion_to_viz.CA) <- c("Sample_ID", "Negative_cohesion")

# Merging both pos and neg cohesion
cohesion_to_viz.CA <- left_join(pos.cohesion_to_viz.CA, neg.cohesion_to_viz.CA)
# Computing the ratio
cohesion_to_viz.CA$Ratio_pos_neg <- abs(cohesion_to_viz.CA$Positive_cohesion/cohesion_to_viz.CA$Negative_cohesion)
cohesion_to_viz.CA$Ratio_neg_pos <- abs(cohesion_to_viz.CA$Negative_cohesion/cohesion_to_viz.CA$Positive_cohesion)

### Getting the stats now
# Calculate median and SD for each group
cohesion_stats.CA <- ddply(left_join(cohesion_to_viz.CA,
  sample_data(pMAGs_95ANI_phyloseq_clr) %>% 
    as.data.frame()) %>% 
    column_to_rownames("Sample_ID") %>%
    dplyr::select("Positive_cohesion", "Negative_cohesion", "Ratio_pos_neg", "Open_or_Closed_to_fishing"),
               .(Open_or_Closed_to_fishing),  # Specify the grouping variable
               summarize,
               median_Positive_cohesion = median(Positive_cohesion, na.rm = TRUE),
               SD_Positive_cohesion = sd(Positive_cohesion, na.rm = TRUE),
               median_Negative_cohesion = median(Negative_cohesion, na.rm = TRUE),
               SD_Negative_cohesion = sd(Negative_cohesion, na.rm = TRUE),
               median_Ratio_pos_neg = median(Ratio_pos_neg, na.rm = TRUE),
               SD_Ratio_pos_neg = sd(Ratio_pos_neg, na.rm = TRUE)
  )

# Perform pairwise Wilcoxon tests and get the results
Wilcoxon.cohesion_stats.CA <- left_join(cohesion_to_viz.CA, 
                            sample_data(pMAGs_95ANI_phyloseq_clr) %>% 
                              as.data.frame()) %>%
  pairwise_wilcox_test(Ratio_pos_neg ~ Open_or_Closed_to_fishing)

# Extract the W-statistic and p-values, and format them for plotting
Wilcoxon.cohesion_stats_text.CA <- Wilcoxon.cohesion_stats.CA %>%
  mutate(
    stat_label = paste("W =", round(statistic, 2), "\np =", round(p, 3)),
    y.position = max(cohesion_to_viz.CA$Ratio_pos_neg) + 0.1  # Position above the boxplots
  )

# Visualising now
cohesion.boxplots.CA <- left_join(cohesion_to_viz.CA,
  sample_data(pMAGs_95ANI_phyloseq_clr) %>% 
    as.data.frame()) %>% 
  ggplot() +
  geom_boxplot(aes(x = Open_or_Closed_to_fishing,
                   y = Ratio_pos_neg, fill = Open_or_Closed_to_fishing)) +
        geom_jitter(aes(y = Ratio_pos_neg, 
                  x = Open_or_Closed_to_fishing 
#                  color = Overall_GroupContrib
),
              width = 0.2, # adjust width to control the spread of the points
              size = 1.2,   # adjust size for better visibility
              alpha = 0.5) + # adjust transparency if needed
    geom_text(data = cohesion_stats.CA, 
            aes(x = Open_or_Closed_to_fishing, 
                y = median_Ratio_pos_neg + 0.1,  # Adjust position above the boxplot
                label = paste("Median:", round(median_Ratio_pos_neg, 2), "\nSD:", round(SD_Ratio_pos_neg, 2))),
            size = 5, 
            position = position_nudge(x = 0.1),  # Adjust for better placement if needed
            color = "black") +
  geom_text(data = Wilcoxon.cohesion_stats.CA, 
            aes(x = group1, 
                y = 1.3,  # Adjust position to always be when y = 1, I will modify this later in Inkscape
                label = paste("W:", statistic, "\np-value adj:", p.adj)),
            size = 5, 
            color = "black") +
  facet_wrap(~SECTOR_N_S, scales = "free", nrow = 2, ncol = 4) +
  ylab("Positive/Negative Cohesion ratio") +
  scale_fill_manual(values = c("seagreen3", # Closed
                              "steelblue4") # Open
                ) +
  theme_bw() +
  theme(axis.text.x = element_blank(),
        legend.position = "none") +
stat_pvalue_manual(left_join(cohesion_to_viz.CA,
  sample_data(pMAGs_95ANI_phyloseq_clr) %>% 
    as.data.frame()) %>% 
                     pairwise_wilcox_test(Ratio_pos_neg ~ Open_or_Closed_to_fishing) %>%
                       add_xy_position())
cohesion.boxplots.CA
```

Now within the Innisfail sector

```{r Computing observed and expected correlations within sector IN, eval=FALSE, message = FALSE, warning=FALSE, echo=TRUE}
# Create observed correlation matrix
cor.mat.true.IN <- cor(rel.d.IN)

# Create vector to hold median otu-otu correlations for initial otu
med.tax.cors.IN <- vector()

# Run this loop for the null model to get expected pairwise correlations
# Bypass null model if the option to input custom correlation matrix is TRUE
if(use.custom.cors == F) {
if(tax.shuffle) {
  for(which.taxon in 1:dim(rel.d.IN)[2]){
    
    #create vector to hold correlations from every permutation for each single otu
    ## perm.cor.vec.mat stands for permuted correlations vector matrix
    perm.cor.vec.mat.IN <- vector()
    
    for(i in 1:iter){
      #Create empty matrix of same dimension as rel.d
      perm.rel.d.IN <- matrix(numeric(0), dim(rel.d.IN)[1], dim(rel.d.IN)[2])
      rownames(perm.rel.d.IN) <- rownames(rel.d.IN)
      colnames(perm.rel.d.IN) <- colnames(rel.d.IN)
      
      #For each otu
      for(j in 1:dim(rel.d.IN)[2]){ 
        # Replace the original taxon vector with a permuted taxon vector
        perm.rel.d.IN[, j ] <- sample(rel.d.IN[ ,j ]) 
      }
      
      # Do not randomize focal column 
      perm.rel.d.IN[, which.taxon] <- rel.d.IN[ , which.taxon]
      
      # Calculate correlation matrix of permuted matrix
      cor.mat.null.IN <- cor(perm.rel.d.IN)
      
      # For each iteration, save the vector of null matrix correlations between focal taxon and other taxa
      perm.cor.vec.mat.IN <- cbind(perm.cor.vec.mat.IN, cor.mat.null.IN[, which.taxon])
      
    }
    # Save the median correlations between the focal taxon and all other taxa  
    med.tax.cors.IN <- cbind(med.tax.cors.IN, apply(perm.cor.vec.mat.IN, 1, median))
    
    # For large datasets, this can be helpful to know how long this loop will run
    if(which.taxon %% 20 == 0){print(which.taxon)}
  }
} else {
  for(which.taxon in 1:dim(rel.d.IN)[2]){
    
    #create vector to hold correlations from every permutation for each single otu
    ## perm.cor.vec.mat stands for permuted correlations vector matrix
    perm.cor.vec.mat.IN <- vector()
    
    for(i in 1:iter){
      #Create duplicate matrix to shuffle abundances
      perm.rel.d.IN <- rel.d.IN 
      
      #For each taxon
      for(j in 1:dim(rel.d.IN)[1]){ 
        which.replace <- which(rel.d.IN[j, ] > 0 ) 
        # if the focal taxon is greater than zero, take it out of the replacement vector, so the focal abundance stays the same
        which.replace.nonfocal <- which.replace[!(which.replace %in% which.taxon)]
        
        #Replace the original taxon vector with a vector where the values greater than 0 have been randomly permuted 
        perm.rel.d.IN[j, which.replace.nonfocal] <- sample(rel.d.IN[ j, which.replace.nonfocal]) 
      }

      # Calculate correlation matrix of permuted matrix
      cor.mat.null.IN <- cor(perm.rel.d.IN)
      
      # For each iteration, save the vector of null matrix correlations between focal taxon and other taxa
      perm.cor.vec.mat.IN <- cbind(perm.cor.vec.mat.IN, cor.mat.null.IN[, which.taxon])
      
    }
    # Save the median correlations between the focal taxon and all other taxa  
    med.tax.cors.IN <- cbind(med.tax.cors.IN, apply(perm.cor.vec.mat.IN, 1, median))
    
    # For large datasets, this can be helpful to know how long this loop will run
    if(which.taxon %% 20 == 0){print(which.taxon)}
  }
 }
}
```

```{r IN - Computing Observed minus expected correlations, eval=FALSE, message = FALSE, warning=FALSE, echo=TRUE, results='hide'}
# Save observed minus expected correlations. Use custom correlations if use.custom.cors = TRUE
if(use.custom.cors == T) {
  obs.exp.cors.mat <- custom.cor.mat.sub
  } else {
    obs.exp.cors.mat.IN <- cor.mat.true.IN - med.tax.cors.IN
  }
  
diag(obs.exp.cors.mat.IN) <- 0
```

```{r IN - Saving the cohesion and connectedness output, eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE, results='hide'}
#### 
#### Produce desired vectors of connectedness and cohesion 

# Calculate connectedness by averaging positive and negative observed - expected correlations
connectedness.pos.IN <- apply(obs.exp.cors.mat.IN, 2, pos.mean)
connectedness.neg.IN <- apply(obs.exp.cors.mat.IN, 2, neg.mean)

# Calculate cohesion by multiplying the relative abundance dataset by associated connectedness
cohesion.pos.IN <- rel.d.IN %*% connectedness.pos.IN
cohesion.neg.IN <- rel.d.IN %*% connectedness.neg.IN

####
#### Combine vectors into one list and print 
output.IN <- list(connectedness.neg.IN, connectedness.pos.IN, cohesion.neg.IN, cohesion.pos.IN)
names(output.IN) <- c("Negative Connectedness", "Positive Connectedness", "Negative Cohesion", "Positive Cohesion")
# print(output.IN)
```

```{r IN Positive to negative cohesion ratio within the Inninsfail sector, fig.INp="The positive:negative cohesion ratio computed within the Inninsfail sector. The boxplots show inner quartiles and median positive:negative cohesion (shown as an absolute value) on the y axis. A higher value indicates a prevalence of positive compared to negative interactions in the microbial community. X-axis shows the reefs that are open or closed to fishing.", fig.height=3, fig.width=3, eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE, fig.show='hide'}
# Df for positive cohesion
pos.cohesion_to_viz.IN <- cohesion.pos.IN %>%
  as.data.frame() %>%
  rownames_to_column("Sample_ID")
colnames(pos.cohesion_to_viz.IN) <- c("Sample_ID", "Positive_cohesion")

# Df for negative cohesion
neg.cohesion_to_viz.IN <- cohesion.neg.IN %>%
  as.data.frame() %>%
  rownames_to_column("Sample_ID")
colnames(neg.cohesion_to_viz.IN) <- c("Sample_ID", "Negative_cohesion")

# Merging both pos and neg cohesion
cohesion_to_viz.IN <- left_join(pos.cohesion_to_viz.IN, neg.cohesion_to_viz.IN)
# Computing the ratio
cohesion_to_viz.IN$Ratio_pos_neg <- abs(cohesion_to_viz.IN$Positive_cohesion/cohesion_to_viz.IN$Negative_cohesion)
cohesion_to_viz.IN$Ratio_neg_pos <- abs(cohesion_to_viz.IN$Negative_cohesion/cohesion_to_viz.IN$Positive_cohesion)

### Getting the stats now
# Calculate median and SD for each group
cohesion_stats.IN <- ddply(left_join(cohesion_to_viz.IN,
  sample_data(pMAGs_95ANI_phyloseq_clr) %>% 
    as.data.frame()) %>% 
    column_to_rownames("Sample_ID") %>%
    dplyr::select("Positive_cohesion", "Negative_cohesion", "Ratio_pos_neg", "Open_or_Closed_to_fishing"),
               .(Open_or_Closed_to_fishing),  # Specify the grouping variable
               summarize,
               median_Positive_cohesion = median(Positive_cohesion, na.rm = TRUE),
               SD_Positive_cohesion = sd(Positive_cohesion, na.rm = TRUE),
               median_Negative_cohesion = median(Negative_cohesion, na.rm = TRUE),
               SD_Negative_cohesion = sd(Negative_cohesion, na.rm = TRUE),
               median_Ratio_pos_neg = median(Ratio_pos_neg, na.rm = TRUE),
               SD_Ratio_pos_neg = sd(Ratio_pos_neg, na.rm = TRUE)
  )

# Perform pairwise Wilcoxon tests and get the results
Wilcoxon.cohesion_stats.IN <- left_join(cohesion_to_viz.IN, 
                            sample_data(pMAGs_95ANI_phyloseq_clr) %>% 
                              as.data.frame()) %>%
  pairwise_wilcox_test(Ratio_pos_neg ~ Open_or_Closed_to_fishing)

# Extract the W-statistic and p-values, and format them for plotting
Wilcoxon.cohesion_stats_text.IN <- Wilcoxon.cohesion_stats.IN %>%
  mutate(
    stat_label = paste("W =", round(statistic, 2), "\np =", round(p, 3)),
    y.position = max(cohesion_to_viz.IN$Ratio_pos_neg) + 0.1  # Position above the boxplots
  )

# Visualising now
cohesion.boxplots.IN <- left_join(cohesion_to_viz.IN,
  sample_data(pMAGs_95ANI_phyloseq_clr) %>% 
    as.data.frame()) %>% 
  ggplot() +
  geom_boxplot(aes(x = Open_or_Closed_to_fishing,
                   y = Ratio_pos_neg, fill = Open_or_Closed_to_fishing)) +
        geom_jitter(aes(y = Ratio_pos_neg, 
                  x = Open_or_Closed_to_fishing 
#                  color = Overall_GroupContrib
),
              width = 0.2, # adjust width to control the spread of the points
              size = 1.2,   # adjust size for better visibility
              alpha = 0.5) + # adjust transparency if needed
    geom_text(data = cohesion_stats.IN, 
            aes(x = Open_or_Closed_to_fishing, 
                y = median_Ratio_pos_neg + 0.1,  # Adjust position above the boxplot
                label = paste("Median:", round(median_Ratio_pos_neg, 2), "\nSD:", round(SD_Ratio_pos_neg, 2))),
            size = 5, 
            position = position_nudge(x = 0.1),  # Adjust for better placement if needed
            color = "black") +
  geom_text(data = Wilcoxon.cohesion_stats.IN, 
            aes(x = group1, 
                y = 1,  # Adjust position to always be when y = 1, I will modify this later in Inkscape
                label = paste("W:", statistic, "\np-value adj:", p.adj)),
            size = 5, 
            color = "black") +
  facet_wrap(~SECTOR_N_S, scales = "free", nrow = 2, ncol = 4) +
  ylab("Positive/Negative Cohesion ratio") +
  scale_fill_manual(values = c("seagreen3", # Closed
                              "steelblue4") # Open
                ) +
  theme_bw() +
  theme(axis.text.x = element_blank(),
        legend.position = "none") +
stat_pvalue_manual(left_join(cohesion_to_viz.IN,
  sample_data(pMAGs_95ANI_phyloseq_clr) %>% 
    as.data.frame()) %>% 
                     pairwise_wilcox_test(Ratio_pos_neg ~ Open_or_Closed_to_fishing) %>%
                       add_xy_position())
cohesion.boxplots.IN
```

Now within the Townsville sector

```{r Computing observed and expected correlations within sector TO, eval=FALSE, message = FALSE, warning=FALSE, echo=TRUE}
# Create observed correlation matrix
cor.mat.true.TO <- cor(rel.d.TO)

# Create vector to hold median otu-otu correlations for initial otu
med.tax.cors.TO <- vector()

# Run this loop for the null model to get expected pairwise correlations
# Bypass null model if the option to input custom correlation matrix is TRUE
if(use.custom.cors == F) {
if(tax.shuffle) {
  for(which.taxon in 1:dim(rel.d.TO)[2]){
    
    #create vector to hold correlations from every permutation for each single otu
    ## perm.cor.vec.mat stands for permuted correlations vector matrix
    perm.cor.vec.mat.TO <- vector()
    
    for(i in 1:iter){
      #Create empty matrix of same dimension as rel.d
      perm.rel.d.TO <- matrix(numeric(0), dim(rel.d.TO)[1], dim(rel.d.TO)[2])
      rownames(perm.rel.d.TO) <- rownames(rel.d.TO)
      colnames(perm.rel.d.TO) <- colnames(rel.d.TO)
      
      #For each otu
      for(j in 1:dim(rel.d.TO)[2]){ 
        # Replace the original taxon vector with a permuted taxon vector
        perm.rel.d.TO[, j ] <- sample(rel.d.TO[ ,j ]) 
      }
      
      # Do not randomize focal column 
      perm.rel.d.TO[, which.taxon] <- rel.d.TO[ , which.taxon]
      
      # Calculate correlation matrix of permuted matrix
      cor.mat.null.TO <- cor(perm.rel.d.TO)
      
      # For each iteration, save the vector of null matrix correlations between focal taxon and other taxa
      perm.cor.vec.mat.TO <- cbind(perm.cor.vec.mat.TO, cor.mat.null.TO[, which.taxon])
      
    }
    # Save the median correlations between the focal taxon and all other taxa  
    med.tax.cors.TO <- cbind(med.tax.cors.TO, apply(perm.cor.vec.mat.TO, 1, median))
    
    # For large datasets, this can be helpful to know how long this loop will run
    if(which.taxon %% 20 == 0){print(which.taxon)}
  }
} else {
  for(which.taxon in 1:dim(rel.d.TO)[2]){
    
    #create vector to hold correlations from every permutation for each single otu
    ## perm.cor.vec.mat stands for permuted correlations vector matrix
    perm.cor.vec.mat.TO <- vector()
    
    for(i in 1:iter){
      #Create duplicate matrix to shuffle abundances
      perm.rel.d.TO <- rel.d.TO 
      
      #For each taxon
      for(j in 1:dim(rel.d.TO)[1]){ 
        which.replace <- which(rel.d.TO[j, ] > 0 ) 
        # if the focal taxon is greater than zero, take it out of the replacement vector, so the focal abundance stays the same
        which.replace.nonfocal <- which.replace[!(which.replace %in% which.taxon)]
        
        #Replace the original taxon vector with a vector where the values greater than 0 have been randomly permuted 
        perm.rel.d.TO[j, which.replace.nonfocal] <- sample(rel.d.TO[ j, which.replace.nonfocal]) 
      }

      # Calculate correlation matrix of permuted matrix
      cor.mat.null.TO <- cor(perm.rel.d.TO)
      
      # For each iteration, save the vector of null matrix correlations between focal taxon and other taxa
      perm.cor.vec.mat.TO <- cbind(perm.cor.vec.mat.TO, cor.mat.null.TO[, which.taxon])
      
    }
    # Save the median correlations between the focal taxon and all other taxa  
    med.tax.cors.TO <- cbind(med.tax.cors.TO, apply(perm.cor.vec.mat.TO, 1, median))
    
    # For large datasets, this can be helpful to know how long this loop will run
    if(which.taxon %% 20 == 0){print(which.taxon)}
  }
 }
}
```

```{r TO - Computing Observed minus expected correlations, eval=FALSE, message = FALSE, warning=FALSE, echo=TRUE, results='hide'}
# Save observed minus expected correlations. Use custom correlations if use.custom.cors = TRUE
if(use.custom.cors == T) {
  obs.exp.cors.mat <- custom.cor.mat.sub
  } else {
    obs.exp.cors.mat.TO <- cor.mat.true.TO - med.tax.cors.TO
  }
  
diag(obs.exp.cors.mat.TO) <- 0
```

```{r TO - Saving the cohesion and connectedness output, eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE, results='hide'}
#### 
#### Produce desired vectors of connectedness and cohesion 

# Calculate connectedness by averaging positive and negative observed - expected correlations
connectedness.pos.TO <- apply(obs.exp.cors.mat.TO, 2, pos.mean)
connectedness.neg.TO <- apply(obs.exp.cors.mat.TO, 2, neg.mean)

# Calculate cohesion by multiplying the relative abundance dataset by associated connectedness
cohesion.pos.TO <- rel.d.TO %*% connectedness.pos.TO
cohesion.neg.TO <- rel.d.TO %*% connectedness.neg.TO

####
#### Combine vectors into one list and print 
output.TO <- list(connectedness.neg.TO, connectedness.pos.TO, cohesion.neg.TO, cohesion.pos.TO)
names(output.TO) <- c("Negative Connectedness", "Positive Connectedness", "Negative Cohesion", "Positive Cohesion")
# print(output.TO)
```

```{r TO Positive to negative cohesion ratio within the Townsville sector, fig.cap="The positive:negative cohesion ratio computed within the Townsville sector. The boxplots show inner quartiles and median positive:negative cohesion (shown as an absolute value) on the y axis. A higher value indicates a prevalence of positive compared to negative interactions in the microbial community. X-axis shows the reefs that are open or closed to fishing.", fig.height=3, fig.width=3, eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE, fig.show='hide'}
# Df for positive cohesion
pos.cohesion_to_viz.TO <- cohesion.pos.TO %>%
  as.data.frame() %>%
  rownames_to_column("Sample_ID")
colnames(pos.cohesion_to_viz.TO) <- c("Sample_ID", "Positive_cohesion")

# Df for negative cohesion
neg.cohesion_to_viz.TO <- cohesion.neg.TO %>%
  as.data.frame() %>%
  rownames_to_column("Sample_ID")
colnames(neg.cohesion_to_viz.TO) <- c("Sample_ID", "Negative_cohesion")

# Merging both pos and neg cohesion
cohesion_to_viz.TO <- left_join(pos.cohesion_to_viz.TO, neg.cohesion_to_viz.TO)
# Computing the ratio
cohesion_to_viz.TO$Ratio_pos_neg <- abs(cohesion_to_viz.TO$Positive_cohesion/cohesion_to_viz.TO$Negative_cohesion)
cohesion_to_viz.TO$Ratio_neg_pos <- abs(cohesion_to_viz.TO$Negative_cohesion/cohesion_to_viz.TO$Positive_cohesion)

### Getting the stats now
# Calculate median and SD for each group
cohesion_stats.TO <- ddply(left_join(cohesion_to_viz.TO,
  sample_data(pMAGs_95ANI_phyloseq_clr) %>% 
    as.data.frame()) %>% 
    column_to_rownames("Sample_ID") %>%
    dplyr::select("Positive_cohesion", "Negative_cohesion", "Ratio_pos_neg", "Open_or_Closed_to_fishing"),
               .(Open_or_Closed_to_fishing),  # Specify the grouping variable
               summarize,
               median_Positive_cohesion = median(Positive_cohesion, na.rm = TRUE),
               SD_Positive_cohesion = sd(Positive_cohesion, na.rm = TRUE),
               median_Negative_cohesion = median(Negative_cohesion, na.rm = TRUE),
               SD_Negative_cohesion = sd(Negative_cohesion, na.rm = TRUE),
               median_Ratio_pos_neg = median(Ratio_pos_neg, na.rm = TRUE),
               SD_Ratio_pos_neg = sd(Ratio_pos_neg, na.rm = TRUE)
  )

# Perform pairwise Wilcoxon tests and get the results
Wilcoxon.cohesion_stats.TO <- left_join(cohesion_to_viz.TO, 
                            sample_data(pMAGs_95ANI_phyloseq_clr) %>% 
                              as.data.frame()) %>%
  pairwise_wilcox_test(Ratio_pos_neg ~ Open_or_Closed_to_fishing)

# Extract the W-statistic and p-values, and format them for plotting
Wilcoxon.cohesion_stats_text.TO <- Wilcoxon.cohesion_stats.TO %>%
  mutate(
    stat_label = paste("W =", round(statistic, 2), "\np =", round(p, 3)),
    y.position = max(cohesion_to_viz.TO$Ratio_pos_neg) + 0.1  # Position above the boxplots
  )

# Visualising now
cohesion.boxplots.TO <- left_join(cohesion_to_viz.TO,
  sample_data(pMAGs_95ANI_phyloseq_clr) %>% 
    as.data.frame()) %>% 
  ggplot() +
  geom_boxplot(aes(x = Open_or_Closed_to_fishing,
                   y = Ratio_pos_neg, fill = Open_or_Closed_to_fishing)) +
        geom_jitter(aes(y = Ratio_pos_neg, 
                  x = Open_or_Closed_to_fishing 
#                  color = Overall_GroupContrib
),
              width = 0.2, # adjust width to control the spread of the points
              size = 1.2,   # adjust size for better visibility
              alpha = 0.5) + # adjust transparency if needed
    geom_text(data = cohesion_stats.TO, 
            aes(x = Open_or_Closed_to_fishing, 
                y = median_Ratio_pos_neg + 0.1,  # Adjust position above the boxplot
                label = paste("Median:", round(median_Ratio_pos_neg, 2), "\nSD:", round(SD_Ratio_pos_neg, 2))),
            size = 5, 
            position = position_nudge(x = 0.1),  # Adjust for better placement if needed
            color = "black") +
  geom_text(data = Wilcoxon.cohesion_stats.TO, 
            aes(x = group1, 
                y = 1,  # Adjust position to always be when y = 1, I will modify this later in Inkscape
                label = paste("W:", statistic, "\np-value adj:", p.adj)),
            size = 5, 
            color = "black") +
  facet_wrap(~SECTOR_N_S, scales = "free", nrow = 2, ncol = 4) +
  ylab("Positive/Negative Cohesion ratio") +
  scale_fill_manual(values = c("seagreen3", # Closed
                              "steelblue4") # Open
                ) +
  theme_bw() +
  theme(axis.text.x = element_blank(),
        legend.position = "none") +
stat_pvalue_manual(left_join(cohesion_to_viz.TO,
  sample_data(pMAGs_95ANI_phyloseq_clr) %>% 
    as.data.frame()) %>% 
                     pairwise_wilcox_test(Ratio_pos_neg ~ Open_or_Closed_to_fishing) %>%
                       add_xy_position())
cohesion.boxplots.TO
```

Now within the Swains sector

```{r Computing observed and expected correlations within sector SW, eval=FALSE, message = FALSE, warning=FALSE, echo=TRUE}
# Create observed correlation matrix
cor.mat.true.SW <- cor(rel.d.SW)

# Create vector to hold median otu-otu correlations for initial otu
med.tax.cors.SW <- vector()

# Run this loop for the null model to get expected pairwise correlations
# Bypass null model if the option to input custom correlation matrix is TRUE
if(use.custom.cors == F) {
if(tax.shuffle) {
  for(which.taxon in 1:dim(rel.d.SW)[2]){
    
    #create vector to hold correlations from every permutation for each single otu
    ## perm.cor.vec.mat stands for permuted correlations vector matrix
    perm.cor.vec.mat.SW <- vector()
    
    for(i in 1:iter){
      #Create empty matrix of same dimension as rel.d
      perm.rel.d.SW <- matrix(numeric(0), dim(rel.d.SW)[1], dim(rel.d.SW)[2])
      rownames(perm.rel.d.SW) <- rownames(rel.d.SW)
      colnames(perm.rel.d.SW) <- colnames(rel.d.SW)
      
      #For each otu
      for(j in 1:dim(rel.d.SW)[2]){ 
        # Replace the original taxon vector with a permuted taxon vector
        perm.rel.d.SW[, j ] <- sample(rel.d.SW[ ,j ]) 
      }
      
      # Do not randomize focal column 
      perm.rel.d.SW[, which.taxon] <- rel.d.SW[ , which.taxon]
      
      # Calculate correlation matrix of permuted matrix
      cor.mat.null.SW <- cor(perm.rel.d.SW)
      
      # For each iteration, save the vector of null matrix correlations between focal taxon and other taxa
      perm.cor.vec.mat.SW <- cbind(perm.cor.vec.mat.SW, cor.mat.null.SW[, which.taxon])
      
    }
    # Save the median correlations between the focal taxon and all other taxa  
    med.tax.cors.SW <- cbind(med.tax.cors.SW, apply(perm.cor.vec.mat.SW, 1, median))
    
    # For large datasets, this can be helpful to know how long this loop will run
    if(which.taxon %% 20 == 0){print(which.taxon)}
  }
} else {
  for(which.taxon in 1:dim(rel.d.SW)[2]){
    
    #create vector to hold correlations from every permutation for each single otu
    ## perm.cor.vec.mat stands for permuted correlations vector matrix
    perm.cor.vec.mat.SW <- vector()
    
    for(i in 1:iter){
      #Create duplicate matrix to shuffle abundances
      perm.rel.d.SW <- rel.d.SW 
      
      #For each taxon
      for(j in 1:dim(rel.d.SW)[1]){ 
        which.replace <- which(rel.d.SW[j, ] > 0 ) 
        # if the focal taxon is greater than zero, take it out of the replacement vector, so the focal abundance stays the same
        which.replace.nonfocal <- which.replace[!(which.replace %in% which.taxon)]
        
        #Replace the original taxon vector with a vector where the values greater than 0 have been randomly permuted 
        perm.rel.d.SW[j, which.replace.nonfocal] <- sample(rel.d.SW[ j, which.replace.nonfocal]) 
      }

      # Calculate correlation matrix of permuted matrix
      cor.mat.null.SW <- cor(perm.rel.d.SW)
      
      # For each iteration, save the vector of null matrix correlations between focal taxon and other taxa
      perm.cor.vec.mat.SW <- cbind(perm.cor.vec.mat.SW, cor.mat.null.SW[, which.taxon])
      
    }
    # Save the median correlations between the focal taxon and all other taxa  
    med.tax.cors.SW <- cbind(med.tax.cors.SW, apply(perm.cor.vec.mat.SW, 1, median))
    
    # For large datasets, this can be helpful to know how long this loop will run
    if(which.taxon %% 20 == 0){print(which.taxon)}
  }
 }
}
```

```{r SW - Computing Observed minus expected correlations, eval=FALSE, message = FALSE, warning=FALSE, echo=TRUE, results='hide'}
# Save observed minus expected correlations. Use custom correlations if use.custom.cors = TRUE
if(use.custom.cors == T) {
  obs.exp.cors.mat <- custom.cor.mat.sub
  } else {
    obs.exp.cors.mat.SW <- cor.mat.true.SW - med.tax.cors.SW
  }
  
diag(obs.exp.cors.mat.SW) <- 0
```

```{r SW - Saving the cohesion and connectedness output, eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE, results='hide'}
#### 
#### Produce desired vectors of connectedness and cohesion 

# Calculate connectedness by averaging positive and negative observed - expected correlations
connectedness.pos.SW <- apply(obs.exp.cors.mat.SW, 2, pos.mean)
connectedness.neg.SW <- apply(obs.exp.cors.mat.SW, 2, neg.mean)

# Calculate cohesion by multiplying the relative abundance dataset by associated connectedness
cohesion.pos.SW <- rel.d.SW %*% connectedness.pos.SW
cohesion.neg.SW <- rel.d.SW %*% connectedness.neg.SW

####
#### Combine vectors into one list and print 
output.SW <- list(connectedness.neg.SW, connectedness.pos.SW, cohesion.neg.SW, cohesion.pos.SW)
names(output.SW) <- c("Negative Connectedness", "Positive Connectedness", "Negative Cohesion", "Positive Cohesion")
# print(output.SW)
```

```{r SW Positive to negative cohesion ratio within the Swains sector, fig.cap="The positive:negative cohesion ratio computed within the Swains sector. The boxplots show inner quartiles and median positive:negative cohesion (shown as an absolute value) on the y axis. A higher value indicates a prevalence of positive compared to negative interactions in the microbial community. X-axis shows the reefs that are open or closed to fishing.", fig.height=3, fig.width=3, eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE, fig.show='hide'}
# Df for positive cohesion
pos.cohesion_to_viz.SW <- cohesion.pos.SW %>%
  as.data.frame() %>%
  rownames_to_column("Sample_ID")
colnames(pos.cohesion_to_viz.SW) <- c("Sample_ID", "Positive_cohesion")

# Df for negative cohesion
neg.cohesion_to_viz.SW <- cohesion.neg.SW %>%
  as.data.frame() %>%
  rownames_to_column("Sample_ID")
colnames(neg.cohesion_to_viz.SW) <- c("Sample_ID", "Negative_cohesion")

# Merging both pos and neg cohesion
cohesion_to_viz.SW <- left_join(pos.cohesion_to_viz.SW, neg.cohesion_to_viz.SW)
# Computing the ratio
cohesion_to_viz.SW$Ratio_pos_neg <- abs(cohesion_to_viz.SW$Positive_cohesion/cohesion_to_viz.SW$Negative_cohesion)
cohesion_to_viz.SW$Ratio_neg_pos <- abs(cohesion_to_viz.SW$Negative_cohesion/cohesion_to_viz.SW$Positive_cohesion)

### Getting the stats now
# Calculate median and SD for each group
cohesion_stats.SW <- ddply(left_join(cohesion_to_viz.SW,
  sample_data(pMAGs_95ANI_phyloseq_clr) %>% 
    as.data.frame()) %>% 
    column_to_rownames("Sample_ID") %>%
    dplyr::select("Positive_cohesion", "Negative_cohesion", "Ratio_pos_neg", "Open_or_Closed_to_fishing"),
               .(Open_or_Closed_to_fishing),  # Specify the grouping variable
               summarize,
               median_Positive_cohesion = median(Positive_cohesion, na.rm = TRUE),
               SD_Positive_cohesion = sd(Positive_cohesion, na.rm = TRUE),
               median_Negative_cohesion = median(Negative_cohesion, na.rm = TRUE),
               SD_Negative_cohesion = sd(Negative_cohesion, na.rm = TRUE),
               median_Ratio_pos_neg = median(Ratio_pos_neg, na.rm = TRUE),
               SD_Ratio_pos_neg = sd(Ratio_pos_neg, na.rm = TRUE)
  )

# Perform pairwise Wilcoxon tests and get the results
Wilcoxon.cohesion_stats.SW <- left_join(cohesion_to_viz.SW, 
                            sample_data(pMAGs_95ANI_phyloseq_clr) %>% 
                              as.data.frame()) %>%
  pairwise_wilcox_test(Ratio_pos_neg ~ Open_or_Closed_to_fishing)

# Extract the W-statistic and p-values, and format them for plotting
Wilcoxon.cohesion_stats_text.SW <- Wilcoxon.cohesion_stats.SW %>%
  mutate(
    stat_label = paste("W =", round(statistic, 2), "\np =", round(p, 3)),
    y.position = max(cohesion_to_viz.SW$Ratio_pos_neg) + 0.1  # Position above the boxplots
  )

# Visualising now
cohesion.boxplots.SW <- left_join(cohesion_to_viz.SW,
  sample_data(pMAGs_95ANI_phyloseq_clr) %>% 
    as.data.frame()) %>% 
  ggplot() +
  geom_boxplot(aes(x = Open_or_Closed_to_fishing,
                   y = Ratio_pos_neg, fill = Open_or_Closed_to_fishing)) +
        geom_jitter(aes(y = Ratio_pos_neg, 
                  x = Open_or_Closed_to_fishing 
#                  color = Overall_GroupContrib
),
              width = 0.2, # adjust width to control the spread of the points
              size = 1.2,   # adjust size for better visibility
              alpha = 0.5) + # adjust transparency if needed
    geom_text(data = cohesion_stats.SW, 
            aes(x = Open_or_Closed_to_fishing, 
                y = median_Ratio_pos_neg + 0.1,  # Adjust position above the boxplot
                label = paste("Median:", round(median_Ratio_pos_neg, 2), "\nSD:", round(SD_Ratio_pos_neg, 2))),
            size = 5, 
            position = position_nudge(x = 0.1),  # Adjust for better placement if needed
            color = "black") +
  geom_text(data = Wilcoxon.cohesion_stats.SW, 
            aes(x = group1, 
                y = 1,  # Adjust position to always be when y = 1, I will modify this later in Inkscape
                label = paste("W:", statistic, "\np-value adj:", p.adj)),
            size = 5, 
            color = "black") +
  facet_wrap(~SECTOR_N_S, scales = "free", nrow = 2, ncol = 4) +
  ylab("Positive/Negative Cohesion ratio") +
  scale_fill_manual(values = c("seagreen3", # Closed
                              "steelblue4") # Open
                ) +
  theme_bw() +
  theme(axis.text.x = element_blank(),
        legend.position = "none") +
stat_pvalue_manual(left_join(cohesion_to_viz.SW,
  sample_data(pMAGs_95ANI_phyloseq_clr) %>% 
    as.data.frame()) %>% 
                     pairwise_wilcox_test(Ratio_pos_neg ~ Open_or_Closed_to_fishing) %>%
                       add_xy_position())
cohesion.boxplots.SW
```

And last one: the Capricorn Bunker sector

```{r Computing observed and expected correlations within sector CB, eval=FALSE, message = FALSE, warning=FALSE, echo=TRUE}
# Create observed correlation matrix
cor.mat.true.CB <- cor(rel.d.CB)

# Create vector to hold median otu-otu correlations for initial otu
med.tax.cors.CB <- vector()

# Run this loop for the null model to get expected pairwise correlations
# Bypass null model if the option to input custom correlation matrix is TRUE
if(use.custom.cors == F) {
if(tax.shuffle) {
  for(which.taxon in 1:dim(rel.d.CB)[2]){
    
    #create vector to hold correlations from every permutation for each single otu
    ## perm.cor.vec.mat stands for permuted correlations vector matrix
    perm.cor.vec.mat.CB <- vector()
    
    for(i in 1:iter){
      #Create empty matrix of same dimension as rel.d
      perm.rel.d.CB <- matrix(numeric(0), dim(rel.d.CB)[1], dim(rel.d.CB)[2])
      rownames(perm.rel.d.CB) <- rownames(rel.d.CB)
      colnames(perm.rel.d.CB) <- colnames(rel.d.CB)
      
      #For each otu
      for(j in 1:dim(rel.d.CB)[2]){ 
        # Replace the original taxon vector with a permuted taxon vector
        perm.rel.d.CB[, j ] <- sample(rel.d.CB[ ,j ]) 
      }
      
      # Do not randomize focal column 
      perm.rel.d.CB[, which.taxon] <- rel.d.CB[ , which.taxon]
      
      # Calculate correlation matrix of permuted matrix
      cor.mat.null.CB <- cor(perm.rel.d.CB)
      
      # For each iteration, save the vector of null matrix correlations between focal taxon and other taxa
      perm.cor.vec.mat.CB <- cbind(perm.cor.vec.mat.CB, cor.mat.null.CB[, which.taxon])
      
    }
    # Save the median correlations between the focal taxon and all other taxa  
    med.tax.cors.CB <- cbind(med.tax.cors.CB, apply(perm.cor.vec.mat.CB, 1, median))
    
    # For large datasets, this can be helpful to know how long this loop will run
    if(which.taxon %% 20 == 0){print(which.taxon)}
  }
} else {
  for(which.taxon in 1:dim(rel.d.CB)[2]){
    
    #create vector to hold correlations from every permutation for each single otu
    ## perm.cor.vec.mat stands for permuted correlations vector matrix
    perm.cor.vec.mat.CB <- vector()
    
    for(i in 1:iter){
      #Create duplicate matrix to shuffle abundances
      perm.rel.d.CB <- rel.d.CB 
      
      #For each taxon
      for(j in 1:dim(rel.d.CB)[1]){ 
        which.replace <- which(rel.d.CB[j, ] > 0 ) 
        # if the focal taxon is greater than zero, take it out of the replacement vector, so the focal abundance stays the same
        which.replace.nonfocal <- which.replace[!(which.replace %in% which.taxon)]
        
        #Replace the original taxon vector with a vector where the values greater than 0 have been randomly permuted 
        perm.rel.d.CB[j, which.replace.nonfocal] <- sample(rel.d.CB[ j, which.replace.nonfocal]) 
      }

      # Calculate correlation matrix of permuted matrix
      cor.mat.null.CB <- cor(perm.rel.d.CB)
      
      # For each iteration, save the vector of null matrix correlations between focal taxon and other taxa
      perm.cor.vec.mat.CB <- cbind(perm.cor.vec.mat.CB, cor.mat.null.CB[, which.taxon])
      
    }
    # Save the median correlations between the focal taxon and all other taxa  
    med.tax.cors.CB <- cbind(med.tax.cors.CB, apply(perm.cor.vec.mat.CB, 1, median))
    
    # For large datasets, this can be helpful to know how long this loop will run
    if(which.taxon %% 20 == 0){print(which.taxon)}
  }
 }
}
```

```{r CB - Computing Observed minus expected correlations, eval=FALSE, message = FALSE, warning=FALSE, echo=TRUE, results='hide'}
# Save observed minus expected correlations. Use custom correlations if use.custom.cors = TRUE
if(use.custom.cors == T) {
  obs.exp.cors.mat <- custom.cor.mat.sub
  } else {
    obs.exp.cors.mat.CB <- cor.mat.true.CB - med.tax.cors.CB
  }
  
diag(obs.exp.cors.mat.CB) <- 0
```

```{r CB - Saving the cohesion and connectedness output, eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE, results='hide'}
#### 
#### Produce desired vectors of connectedness and cohesion 

# Calculate connectedness by averaging positive and negative observed - expected correlations
connectedness.pos.CB <- apply(obs.exp.cors.mat.CB, 2, pos.mean)
connectedness.neg.CB <- apply(obs.exp.cors.mat.CB, 2, neg.mean)

# Calculate cohesion by multiplying the relative abundance dataset by associated connectedness
cohesion.pos.CB <- rel.d.CB %*% connectedness.pos.CB
cohesion.neg.CB <- rel.d.CB %*% connectedness.neg.CB

####
#### Combine vectors into one list and print 
output.CB <- list(connectedness.neg.CB, connectedness.pos.CB, cohesion.neg.CB, cohesion.pos.CB)
names(output.CB) <- c("Negative Connectedness", "Positive Connectedness", "Negative Cohesion", "Positive Cohesion")
# print(output.CB)
```

```{r SW Positive to negative cohesion ratio within the Capricorn Bunker sector, fig.cap="The positive:negative cohesion ratio computed within the Capricorn Bunker sector. The boxplots show inner quartiles and median positive:negative cohesion (shown as an absolute value) on the y axis. A higher value indicates a prevalence of positive compared to negative interactions in the microbial community. X-axis shows the reefs that are open or closed to fishing.", fig.height=3, fig.width=3, eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE, fig.show='hide'}
# Df for positive cohesion
pos.cohesion_to_viz.CB <- cohesion.pos.CB %>%
  as.data.frame() %>%
  rownames_to_column("Sample_ID")
colnames(pos.cohesion_to_viz.CB) <- c("Sample_ID", "Positive_cohesion")

# Df for negative cohesion
neg.cohesion_to_viz.CB <- cohesion.neg.CB %>%
  as.data.frame() %>%
  rownames_to_column("Sample_ID")
colnames(neg.cohesion_to_viz.CB) <- c("Sample_ID", "Negative_cohesion")

# Merging both pos and neg cohesion
cohesion_to_viz.CB <- left_join(pos.cohesion_to_viz.CB, neg.cohesion_to_viz.CB)
# Computing the ratio
cohesion_to_viz.CB$Ratio_pos_neg <- abs(cohesion_to_viz.CB$Positive_cohesion/cohesion_to_viz.CB$Negative_cohesion)
cohesion_to_viz.CB$Ratio_neg_pos <- abs(cohesion_to_viz.CB$Negative_cohesion/cohesion_to_viz.CB$Positive_cohesion)

### Getting the stats now
# Calculate median and SD for each group
cohesion_stats.CB <- ddply(left_join(cohesion_to_viz.CB,
  sample_data(pMAGs_95ANI_phyloseq_clr) %>% 
    as.data.frame()) %>% 
    column_to_rownames("Sample_ID") %>%
    dplyr::select("Positive_cohesion", "Negative_cohesion", "Ratio_pos_neg", "Open_or_Closed_to_fishing"),
               .(Open_or_Closed_to_fishing),  # Specify the grouping variable
               summarize,
               median_Positive_cohesion = median(Positive_cohesion, na.rm = TRUE),
               SD_Positive_cohesion = sd(Positive_cohesion, na.rm = TRUE),
               median_Negative_cohesion = median(Negative_cohesion, na.rm = TRUE),
               SD_Negative_cohesion = sd(Negative_cohesion, na.rm = TRUE),
               median_Ratio_pos_neg = median(Ratio_pos_neg, na.rm = TRUE),
               SD_Ratio_pos_neg = sd(Ratio_pos_neg, na.rm = TRUE)
  )

# Perform pairwise Wilcoxon tests and get the results
Wilcoxon.cohesion_stats.CB <- left_join(cohesion_to_viz.CB, 
                            sample_data(pMAGs_95ANI_phyloseq_clr) %>% 
                              as.data.frame()) %>%
  pairwise_wilcox_test(Ratio_pos_neg ~ Open_or_Closed_to_fishing)

# Extract the W-statistic and p-values, and format them for plotting
Wilcoxon.cohesion_stats_text <- Wilcoxon.cohesion_stats.CB %>%
  mutate(
    stat_label = paste("W =", round(statistic, 2), "\np =", round(p, 3)),
    y.position = max(cohesion_to_viz.CB$Ratio_pos_neg) + 0.1  # Position above the boxplots
  )

# Visualising now
cohesion.boxplots.CB <- left_join(cohesion_to_viz.CB,
  sample_data(pMAGs_95ANI_phyloseq_clr) %>% 
    as.data.frame()) %>% 
  ggplot() +
  geom_boxplot(aes(x = Open_or_Closed_to_fishing,
                   y = Ratio_pos_neg, fill = Open_or_Closed_to_fishing)) +
        geom_jitter(aes(y = Ratio_pos_neg, 
                  x = Open_or_Closed_to_fishing 
#                  color = Overall_GroupContrib
),
              width = 0.2, # adjust width to control the spread of the points
              size = 1.2,   # adjust size for better visibility
              alpha = 0.5) + # adjust transparency if needed
    geom_text(data = cohesion_stats.CB, 
            aes(x = Open_or_Closed_to_fishing, 
                y = median_Ratio_pos_neg + 0.1,  # Adjust position above the boxplot
                label = paste("Median:", round(median_Ratio_pos_neg, 2), "\nSD:", round(SD_Ratio_pos_neg, 2))),
            size = 5, 
            position = position_nudge(x = 0.1),  # Adjust for better placement if needed
            color = "black") +
  geom_text(data = Wilcoxon.cohesion_stats.CB, 
            aes(x = group1, 
                y = 1,  # Adjust position to always be when y = 1, I will modify this later in Inkscape
                label = paste("W:", statistic, "\np-value adj:", p.adj)),
            size = 5, 
            color = "black") +
  facet_wrap(~SECTOR_N_S, scales = "free", nrow = 2, ncol = 4) +
  ylab("Positive/Negative Cohesion ratio") +
  scale_fill_manual(values = c("seagreen3", # Closed
                              "steelblue4") # Open
                ) +
  theme_bw() +
  theme(axis.text.x = element_blank(),
        legend.position = "none") +
stat_pvalue_manual(left_join(cohesion_to_viz.CB,
  sample_data(pMAGs_95ANI_phyloseq_clr) %>% 
    as.data.frame()) %>% 
                     pairwise_wilcox_test(Ratio_pos_neg ~ Open_or_Closed_to_fishing) %>%
                       add_xy_position())
cohesion.boxplots.CB
```

```{r Visualising the cohesion metrics from all GBR sectors, fig.cap="The positive:negative cohesion ratios, computed separately within GBR sectors. The boxplots show inner quartiles and median positive:negative cohesion (shown as an absolute value) on the y axis. A higher value indicates a prevalence of positive compared to negative interactions in the microbial community. X-axis shows the reefs that are open or closed to fishing.",  fig.height=5, fig.width=12, eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE}
patchwork::wrap_plots(cohesion.boxplots.CG,
                      cohesion.boxplots.PC,
                      cohesion.boxplots.CA,
                      cohesion.boxplots.IN,
                      cohesion.boxplots.TO,
                      cohesion.boxplots.SW,
                      cohesion.boxplots.CB,
                      ncol = 4,
                      nrow = 2)
```

### ***Mann-Whitney U test*** - Are these differences significant?

A Mann-Whitney U test is typically performed when an analyst would like to test for differences between two independent treatments or conditions. However, the continuous response variable of interest is not normally distributed - hence the Mann-Whitney U test is often considered a ***nonparametric*** alternative to an independent sample ***t-test***, and is also known as the ***Wilcoxon Rank Sum***.

```{r Mann Whitney U tests for CG sector, eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE}
# Cape Grenville
wilcox.test.cohesion.CG <- wilcox.test(Ratio_pos_neg ~ Open_or_Closed_to_fishing, 
                   data = cohesion.boxplots.CG$data,
                   exact = FALSE)
wilcox.test.cohesion.CG
```

```{r Mann Whitney U tests for PC sector, eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE}
# Princess Charlotte bay
wilcox.test.cohesion.PC <- wilcox.test(Ratio_pos_neg ~ Open_or_Closed_to_fishing, 
                   data = cohesion.boxplots.PC$data,
                   exact = FALSE)
wilcox.test.cohesion.PC
```

```{r Mann Whitney U tests for CA sector, eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE}
# Cairns
wilcox.test.cohesion.CA <- wilcox.test(Ratio_pos_neg ~ Open_or_Closed_to_fishing, 
                   data = cohesion.boxplots.CA$data,
                   exact = FALSE)
wilcox.test.cohesion.CA
```

```{r Mann Whitney U tests for IN sector, eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE}
# Inninsfail
wilcox.test.cohesion.IN <- wilcox.test(Ratio_pos_neg ~ Open_or_Closed_to_fishing, 
                   data = cohesion.boxplots.IN$data,
                   exact = FALSE)
wilcox.test.cohesion.IN
```

```{r Mann Whitney U tests for TO sector, eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE}
# Townsville
wilcox.test.cohesion.TO <- wilcox.test(Ratio_pos_neg ~ Open_or_Closed_to_fishing, 
                   data = cohesion.boxplots.TO$data,
                   exact = FALSE)
wilcox.test.cohesion.TO
```

```{r Mann Whitney U tests for SW sector, eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE}
# Swains
wilcox.test.cohesion.SW <- wilcox.test(Ratio_pos_neg ~ Open_or_Closed_to_fishing, 
                   data = cohesion.boxplots.SW$data,
                   exact = FALSE)
wilcox.test.cohesion.SW
```

```{r Mann Whitney U tests for CB sector, eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE}
# Capricorn Bunker
wilcox.test.cohesion.CB <- wilcox.test(Ratio_pos_neg ~ Open_or_Closed_to_fishing, 
                   data = cohesion.boxplots.CB$data,
                   exact = FALSE)
wilcox.test.cohesion.CB
```

Based on the Wilkoxon Rank Sum tests, the Pos/Neg cohesion ratios were higher in the no-take compared to take zones in each sector, apart from sectors Swains and Capricorn Bunkern sampled in trip 2 (p value >= 0.05).

This overall suggests a prevalence of positive interactions in no-take zones in comparison to take reefs where mutually exclusive interactions (i.e. competition, predator/prey, pathogen/host, and etc.) may be more dominant.

## Hypothesis 2 - ***high microbial diversity will be positively correlated with positive cohesion*** (proxy for prevalent mutualistic interactions in the community), and ***low microbial diversity will be positively correlated with negative cohesion*** (proxy for prevalent negative/mutually exclusive interactions in the community)

***IMPORTANT*** - Samuel raised a valuable point, highly diverse communities generally result in a more connected graph anyway. So these patterns (positive connections = high diversity) may also be linked to methodological biases of how networks work, it does not mean that one is causing the other. However I think the benefit of cohesion is that we can differentiate between positive and negative connections. But this is something to think about and have in mind later on...

### Shannon index

```{r Shannon diversity notake and take reefs, eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE}
# Shannon diversity
MAGs_shannon <- vegan::diversity(t(MAGs_annotations_RA), index = "shannon")
# Check richness too

# Mann-Whitney U test

# Preparing the objects to visualise as boxplots
# Shannon
megan_genus_shannon_boxplots <- as.data.frame(MAGs_shannon)
megan_genus_shannon_boxplots <- tibble::rownames_to_column(megan_genus_shannon_boxplots, "Sample_ID")
# Adding the metadata
megan_genus_shannon_boxplots <- left_join(megan_genus_shannon_boxplots,
                                          MINT_sector_manually_edited
                                          # metadata_for_MINT_sPLS_with_fish # I had this one in my old code
                                          )
```

```{r Shannon diversity boxplots notake and take reefs, fig.height=3, fig.width=5, eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE, results='hide', fig.show='hide'}
Shannon_div_stats <- ddply(megan_genus_shannon_boxplots %>% 
                             dplyr::select(MAGs_shannon, Open_or_Closed_to_fishing),
                             .(Open_or_Closed_to_fishing),
                           summarize,
                           Median_Shannon = median(MAGs_shannon, na.rm = TRUE),
                           SD_Shannon = sd(MAGs_shannon, na.rm = TRUE)
                           )

### Visualising now:
# Define the custom shapes for each sector
sector_shapes <- c("CG" = 1,  # Filled circle
                   "PC" = 2,  # Filled triangle
                   "SW" = 6,  # Filled diamond
                   "CA" = 3,  # Filled square
                   "CB" = 7,  # Solid circle
                   "TO" = 5,   # Plus sign
                   "IN" = 4)   # Cross

# Define the custom colors for each sector
sector_colors <- c("CG" = "indianred",  # Trip 1
                   "PC" = "indianred",  # Trip 1
                   "SW" = "indianred4",  # Trip 2
                   "CA" = "red3",  # Trip 3
                   "CB" = "indianred4",  # Trip 2
                   "TO" = "slateblue",   # Trip 4
                   "IN" = "red3")   # Trip 3

# Your updated ggplot code with custom shapes AND colors
across_trips_shannon_div_boxplots_open_closed <- ggplot(megan_genus_shannon_boxplots,
       aes(y = MAGs_shannon, x = Open_or_Closed_to_fishing)) +
  geom_boxplot(aes(fill = factor(Open_or_Closed_to_fishing)), show.legend = FALSE) +
  geom_jitter(aes(y = MAGs_shannon, 
                  x = Open_or_Closed_to_fishing,
                  shape = factor(SECTOR),  # Map SECTOR to shape
                  color = factor(SECTOR)), # Map SECTOR to color
              width = 0.2,
              size = 2,
              alpha = 0.7) +  # Increased alpha for better color visibility
  geom_text(data = Shannon_div_stats,
            aes(x = Open_or_Closed_to_fishing,
                y = Median_Shannon + 0.1,
                label = paste(round(Median_Shannon, 2), "±", round(SD_Shannon, 2))),
            size = 5,
            color = "black",
            position = position_nudge(x = 0.1)) +
  scale_fill_manual(values = c("seagreen3", "steelblue4")) +  # Boxplot fill colors
  scale_shape_manual(values = sector_shapes) +  # Custom shapes
  scale_color_manual(values = sector_colors) +  # Custom colors
  labs(title = "Microbial alpha diversity", 
       subtitle = "Between no-take and take reefs",
       y = "Shannon index",
       x = "Reef Management Status") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 12), 
        legend.position = "right") +  # Show legend for shapes/colors
  theme_bw() +
  stat_pvalue_manual(megan_genus_shannon_boxplots %>% 
                       pairwise_wilcox_test(MAGs_shannon ~ Open_or_Closed_to_fishing) %>%
                       add_xy_position())

# Display the plot
across_trips_shannon_div_boxplots_open_closed
```

```{r Mann Whitney U tests for diversity between no-take and take zones, eval=FALSE, message = FALSE, warning=FALSE, echo=TRUE}
wilcox.test.cohesion.div.all <- wilcox.test(MAGs_shannon ~ Open_or_Closed_to_fishing, 
                   data = megan_genus_shannon_boxplots,
                   exact = FALSE)
wilcox.test.cohesion.div.all
```

The Wilcoxon rank sum test suggests that diversity (measured as Shannon index) is lower in take compared to no-take reefs (W = 5432, p-value = 0.01532), but the medians differ slightly, and hence overall, microbial diversity between no-take and take sites is largely comparable.

How about within GBR sectors?

```{r Shannon diversity per trip boxplots notake and take reefs, fig.height=4, fig.width=12, eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE, results='hide', fig.show='hide'}
Shannon_div_stats_Sectors <- ddply(megan_genus_shannon_boxplots %>% 
                             dplyr::select(MAGs_shannon, Open_or_Closed_to_fishing, SECTOR),
                             .(Open_or_Closed_to_fishing, SECTOR),
                           summarize,
                           Median_Shannon = median(MAGs_shannon, na.rm = TRUE),
                           SD_Shannon = sd(MAGs_shannon, na.rm = TRUE)
                           )

# Your ggplot code with different symbols for sectors
per_trip_shannon_div_boxplots_open_closed <- ggplot(megan_genus_shannon_boxplots,
                                                    aes(y = MAGs_shannon, x = Open_or_Closed_to_fishing)) +  # Shannon index
  geom_boxplot(aes(fill = factor(Open_or_Closed_to_fishing)), show.legend = FALSE) +
  geom_jitter(aes(y = MAGs_shannon, 
                  x = Open_or_Closed_to_fishing,
                  shape = factor(SECTOR)),  # Map SECTOR to shape
              width = 0.2,  # Adjust width to control the spread of the points
              size = 2.4,   # Adjust size for better visibility
              alpha = 0.2) +  # Adjust transparency if needed
  geom_text(data = Shannon_div_stats_Sectors,
            aes(x = Open_or_Closed_to_fishing,
                y = Median_Shannon + 0.05,  # Adjust text position above the boxplots
                label = paste(round(Median_Shannon, 2), "±", round(SD_Shannon, 2))),
            size = 5,
            color = "black",
            position = position_nudge(x = 0.1)  # Adjust for better placement if needed
            ) +
  scale_fill_manual(values = c("seagreen3", "steelblue4")) +  # Closed and open colors
  scale_shape_manual(values = sector_shapes) +  # Apply custom shapes based on SECTOR
  facet_wrap(~SECTOR, scales = "free_y", nrow = 2, ncol = 4, strip.position = "left") +
  labs(title = "Alpha diversity - IMOS-MGD 876 pMAGs (dRep 95% ANI)", 
       subtitle = "Between No-Take and Take reefs",
       y = "Reef Management Status",
       x = "Shannon index") +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 12), 
        legend.position = "none") +
  theme_bw()

# Print the plot
per_trip_shannon_div_boxplots_open_closed
```

```{r Shannon diversity boxplots, fig.height=5, fig.width=16, eval=FALSE, message = FALSE, warning=FALSE, echo=TRUE, results='hide', fig.show='hide', cache=TRUE}
# Combine the plots with specified proportions (1:2 ratio)
across_trips_shannon_div_boxplots_open_closed + 
  per_trip_shannon_div_boxplots_open_closed + 
  plot_layout(nrow = 1, ncol = 2, widths = c(1, 3))
```

Are these differences statistically significant?

```{r within sector pairwise Mann Whitney U tests for diversity between no-take and take zones, eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE, cache=TRUE}
### Trying a loop:
# Initialize an empty data frame to store results
results <- data.frame(SECTOR = character(),
                      Wilcoxon_test_comparison = character(),
                      W = numeric(),
                      p_value = numeric(),
                      stringsAsFactors = FALSE)

# Loop through each sector
for (sector in unique(megan_genus_shannon_boxplots$SECTOR)) {
  # Perform the Wilcoxon test
  test_result <- wilcox.test(MAGs_shannon ~ Open_or_Closed_to_fishing, 
                              data = filter(megan_genus_shannon_boxplots, SECTOR == sector),
                              exact = FALSE)
  
  # Append results to the data frame
  results <- rbind(results, data.frame(SECTOR = sector,
                                       Wilcoxon_test_comparison = test_result$data.name,
                                        W = test_result$statistic,
                                        p_value = test_result$p.value))
}

# View the results
print(results)
```

Just double-checking with one sector to see if the loop works well:

```{r Mann Whitney U tests for diversity between no-take and take zones in CG, eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE, cache=TRUE}
# CG
wilcox.test.cohesion.div.CG <- wilcox.test(MAGs_shannon~ Open_or_Closed_to_fishing, 
                   data = filter(megan_genus_shannon_boxplots, SECTOR == "CG"),
                   exact = FALSE)
wilcox.test.cohesion.div.CG
```

Interestingly, the Wilcoxon rank sum test is not significant when performed within sectors.

### Regressing the cohesion metric against diversity

Generally, communities that are more diverse tend to also be more connected, hence this may also influence the cohesion metric (which is a proxy for community conenctivity). Let's see if that's the case for our data: 

```{r Plotting how cohesion and diversity regress, fig.height=8, fig.width=12, eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE}
regression_cohesion_diversity <- left_join(megan_genus_shannon_boxplots %>% 
                                             dplyr::select("Sample_ID",
                                                           "MAGs_shannon",
                                                           "REEF_NAME",
                                                           "SECTOR",
                                                           "Sampling_trip",
                                                           "Open_or_Closed_to_fishing"),
                                           cohesion_to_viz)
# Visualising
patchwork::wrap_plots(
# Regression - Positive cohesion and diversity - color per sample trip
ggplot(regression_cohesion_diversity, # this is my data
       aes(x = MAGs_shannon, y = Positive_cohesion, color = Sampling_trip)) + 
  geom_point() +
  scale_color_manual(values = c("indianred", # Sampling trip 1
                "indianred4", # Sampling trip 2 
                "red3", # Sampling trip 3
                "slateblue") # Sampling trip 4
  ) +
#  scale_color_manual(values = c("seagreen3", # Closed
#                              "steelblue4") # Open
#                     ) +
  stat_smooth(method = "lm", col = "hotpink4") +
  theme_bw(),
# Regression - Positive cohesion and diversity - color per reef zoning
ggplot(regression_cohesion_diversity, # this is my data
       aes(x = MAGs_shannon, y = Positive_cohesion, color = Open_or_Closed_to_fishing)) + 
  geom_point() +
  scale_color_manual(values = c("seagreen3", # Closed
                              "steelblue4") # Open
                     ) +
  stat_smooth(method = "lm", col = "hotpink4") +
  theme_bw(),
# Regression - Negative cohesion and diversity - color per sample trip
ggplot(regression_cohesion_diversity, # this is my data
       aes(x = MAGs_shannon, y = abs(Negative_cohesion), color = Sampling_trip)) +
  geom_point() +
    scale_color_manual(values = c("indianred", # Sampling trip 1
                "indianred4", # Sampling trip 2 
                "red3", # Sampling trip 3
                "slateblue") # Sampling trip 4
  ) +
#  scale_color_manual(values = c("seagreen3", # Closed
#                              "steelblue4") # Open
#                     ) +
  stat_smooth(method = "lm", col = "slategrey") +
  theme_bw(),
# Regression - Negative cohesion and diversity - color per reef zoning
ggplot(regression_cohesion_diversity, # this is my data
       aes(x = MAGs_shannon, y = abs(Negative_cohesion), color = Open_or_Closed_to_fishing)) +
  geom_point() +
  scale_color_manual(values = c("seagreen3", # Closed
                              "steelblue4") # Open
                     ) +
  stat_smooth(method = "lm", col = "slategrey") +
  theme_bw(),
nrow = 2,
ncol = 2
)
```

Based on this plot, the cohesion metric (y-axis) is strongly influenced by diversity (x-axis). ***Communities that are more diverse seem to exhibit a higher prevalence of positive connections (plots above) and less negative interactions (plots below)***. The outlier samples that show high positive cohesion are samples collected in trip 4 - winter (colored in blue in the top-left plot).

***Numerical summary:***
Positive cohesion:
Multiple R-squared:  0.3288,	Adjusted R-squared:  0.3252
F-statistic: 92.08 on 1 and 188 DF,  p-value: 2.2e-16

Negative cohesion:
***Multiple R-squared:  0.6445***,	Adjusted R-squared:  0.6426 
F-statistic: 340.8 on 1 and 188 DF,  ***p-value: < 2.2e-16***

```{r Neg Regression numbers too, eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE}
neg.regression.numeric <- lm(MAGs_shannon ~ abs(Negative_cohesion), data = regression_cohesion_diversity)
summary(neg.regression.numeric)
```

```{r Pos Regression numbers too, eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE}
pos.regression.numeric <- lm(MAGs_shannon ~ Positive_cohesion, data = regression_cohesion_diversity)
summary(pos.regression.numeric)
```

# Connectedness metric

## Hypothesis 3 - ***opportunistic microbes will exhibit negative connectedness*** (proxy for mutualistic interactions, e.g. competition), while microbes with ***streamlined genomes will exhibit positive connectedness*** (potential proxy for mutualistic interactions, e.g. due to metabolite exchange)

Large genomes, high GC content (~60%) and high metabolic independence (measured as completeness of KEGG metabolic pathways in Veseli et al. 2023) are characteristic of opportunistic microbes, which can then outcompete (competition would be measured as negative connectedness) other microbes for nutrients, when nutrients are elevated. Therefore I expect to see ***positive correlation between negative connectedness and (1) genome size, (2) GC content, and (3) metabolic independence***. So starting with each of these metrics one by one:

### Regressing genome size against positive and negative connectedness scores

My hypotheses:
(1) ***positive correlation between larger genomes and negative connectedness*** (i.e. proxy for negative connectivity of that MAG with the rest of the microbial community - potential indicator that this MAG can outcompete others under particular conditions, due to its large genome?)
(2) ***positive correlation between smaller genomes and positive connectedness*** (i.e. proxy for positive connectivity of that MAG with the rest of the microbial community - potential indicator that this MAG is mutualistic and depends on other microbes, perhaps for metabolite exchange?)

Is this also the case for the MINT sPLS indicators?

```{r Visualising regression for pos and neg connectedness with genome size GC and KEGG completeness for MINT sPLS indicators, fig.height=10, fig.width=11, eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE}
# Adding connectedness info to the 
MINT_sPLS_CheckM_stats_and_average_KEGG_completeness_and_connectedness <- left_join(
  MINT_sPLS_CheckM_stats_and_average_KEGG_completeness,
  connectedness.barplots_to_merge)

# Visualising
patchwork::wrap_plots(
  ggplot(MINT_sPLS_CheckM_stats_and_average_KEGG_completeness_and_connectedness, 
       aes(x = Genome.size..bp..CheckM1, y = connectedness.pos, color = Overall_GroupContrib)) + 
  geom_point(show.legend = FALSE) +
  xlab("Genome size (in mbp)") +
  ylab("Positive Connectedness") +
  scale_color_manual(values = c("seagreen3",   # Closed
#                                 "grey",        # Not discriminative in MINT sPLS-DA
                                 "steelblue4") # Open
                     ) +
  stat_smooth(method = "lm", col = "hotpink4", show.legend = FALSE) +
    theme_bw(),
  ggplot(MINT_sPLS_CheckM_stats_and_average_KEGG_completeness_and_connectedness, 
       aes(x = Genome.size..bp..CheckM1, y = connectedness.neg, color = Overall_GroupContrib)) + 
  geom_point() +
  xlab("Genome size (in mbp)") +
  ylab("Negative Connectedness") +
  scale_color_manual(values = c("seagreen3",   # Closed
#                                 "grey",        # Not discriminative in MINT sPLS-DA
                                 "steelblue4") # Open
                     ) +
  stat_smooth(method = "lm", col = "slategrey") +
    theme_bw(),
  ggplot(MINT_sPLS_CheckM_stats_and_average_KEGG_completeness_and_connectedness, 
       aes(x = GC.CheckM1, y = connectedness.pos, color = Overall_GroupContrib)) + 
  geom_point(show.legend = FALSE) +
  xlab("GC content (in %)") +
  ylab("Positive Connectedness") +
  scale_color_manual(values = c("seagreen3",   # Closed
#                                 "grey",        # Not discriminative in MINT sPLS-DA
                                 "steelblue4") # Open
                     ) +
  stat_smooth(method = "lm", col = "hotpink4", show.legend = FALSE) +
    theme_bw(),
  ggplot(MINT_sPLS_CheckM_stats_and_average_KEGG_completeness_and_connectedness, 
       aes(x = GC.CheckM1, y = connectedness.neg, color = Overall_GroupContrib)) + 
  geom_point() +
  xlab("GC content (in %)") +
  ylab("Negative Connectedness") +
  scale_color_manual(values = c("seagreen3",   # Closed
#                                 "grey",        # Not discriminative in MINT sPLS-DA
                                 "steelblue4") # Open
                     ) +
  stat_smooth(method = "lm", col = "slategrey") +
    theme_bw(),
  ggplot(MINT_sPLS_CheckM_stats_and_average_KEGG_completeness_and_connectedness, 
       aes(x = average_KEGG_completeness_per_MAG, y = connectedness.pos, color = Overall_GroupContrib)) + 
  geom_point(show.legend = FALSE) +
  xlab("Average KEGG completeness across modules (ranging 0-1)") +
  ylab("Positive Connectedness") +
  scale_color_manual(values = c("seagreen3",   # Closed
#                                 "grey",        # Not discriminative in MINT sPLS-DA
                                 "steelblue4") # Open
                     ) +
  stat_smooth(method = "lm", col = "hotpink4", show.legend = FALSE) +
    theme_bw(),
  ggplot(MINT_sPLS_CheckM_stats_and_average_KEGG_completeness_and_connectedness, 
       aes(x = average_KEGG_completeness_per_MAG, y = connectedness.neg, color = Overall_GroupContrib)) + 
  geom_point() +
  xlab("Average KEGG completeness across modules (ranging 0-1)") +
  ylab("Negative Connectedness") +
  scale_color_manual(values = c("seagreen3",   # Closed
#                                 "grey",        # Not discriminative in MINT sPLS-DA
                                 "steelblue4") # Open
                     ) +
  stat_smooth(method = "lm", col = "slategrey") +
    theme_bw(),
nrow = 3,
ncol = 2
)
```

```{r Visualising regression for pos neg connectedness ratio with genome size GC and KEGG completeness for MINT sPLS indicators, fig.height=14, fig.width=6, eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE}
MINT_sPLS_CheckM_stats_and_average_KEGG_completeness_and_connectedness
# Visualising
patchwork::wrap_plots(
  ggplot(MINT_sPLS_CheckM_stats_and_average_KEGG_completeness_and_connectedness, 
       aes(x = Genome.size..bp..CheckM1, y = Connectedness_Ratio_pos_neg, color = Overall_GroupContrib)) + 
  geom_point(show.legend = FALSE) +
  xlab("Genome size (in mbp)") +
  ylab("Positive-Negative Connectedness ratio") +
  scale_color_manual(values = c("seagreen3",   # Closed
#                                 "grey",        # Not discriminative in MINT sPLS-DA
                                 "steelblue4") # Open
                     ) +
  stat_smooth(method = "lm", col = "hotpink4", show.legend = FALSE) +
    theme_bw(),
  ggplot(MINT_sPLS_CheckM_stats_and_average_KEGG_completeness_and_connectedness, 
       aes(x = GC.CheckM1, y = Connectedness_Ratio_pos_neg, color = Overall_GroupContrib)) + 
  geom_point(show.legend = FALSE) +
  xlab("GC content (in %)") +
  ylab("Positive-Negative Connectedness ratio") +
  scale_color_manual(values = c("seagreen3",   # Closed
#                                 "grey",        # Not discriminative in MINT sPLS-DA
                                 "steelblue4") # Open
                     ) +
  stat_smooth(method = "lm", col = "hotpink4", show.legend = FALSE) +
    theme_bw(),
  ggplot(MINT_sPLS_CheckM_stats_and_average_KEGG_completeness_and_connectedness, 
       aes(x = average_KEGG_completeness_per_MAG, y = Connectedness_Ratio_pos_neg, color = Overall_GroupContrib)) + 
  geom_point(show.legend = FALSE) +
  xlab("Average KEGG completeness across modules (ranging 0-1)") +
  ylab("Positive-Negative Connectedness ratio") +
  scale_color_manual(values = c("seagreen3",   # Closed
#                                 "grey",        # Not discriminative in MINT sPLS-DA
                                 "steelblue4") # Open
                     ) +
  stat_smooth(method = "lm", col = "hotpink4", show.legend = FALSE) +
    theme_bw(),
nrow = 3,
ncol = 1
)
```


It does look like there is a trend (when using very simple linear regression) - ***smaller genomes show a higher positive connectedness to the community, while larger genomes appear to be negatively connected to the community***. But is this statistically significant? 

```{r Numerical summaries for positive negative connectedness ratio, eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE}
### Numerical summaries
# Genome size
summary(lm(Connectedness_Ratio_pos_neg ~ Genome.size..bp..CheckM1,
          data = MINT_sPLS_CheckM_stats_and_average_KEGG_completeness_and_connectedness))
# GC content
summary(lm(Connectedness_Ratio_pos_neg ~ GC.CheckM1,
          data = MINT_sPLS_CheckM_stats_and_average_KEGG_completeness_and_connectedness))
# KEGG completeness
summary(lm(Connectedness_Ratio_pos_neg ~ average_KEGG_completeness_per_MAG,
          data = MINT_sPLS_CheckM_stats_and_average_KEGG_completeness_and_connectedness))
```

```{r Numerical summaries for positive connectedness, eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE}
### Numerical summaries
# Genome size
summary(lm(connectedness.pos ~ Genome.size..bp..CheckM1,
          data = MINT_sPLS_CheckM_stats_and_average_KEGG_completeness_and_connectedness))
# GC content
summary(lm(connectedness.pos ~ GC.CheckM1,
          data = MINT_sPLS_CheckM_stats_and_average_KEGG_completeness_and_connectedness))
# KEGG completeness
summary(lm(connectedness.pos ~ average_KEGG_completeness_per_MAG,
          data = MINT_sPLS_CheckM_stats_and_average_KEGG_completeness_and_connectedness))
```

```{r Numerical summaries for negative connectedness, eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE}
### Numerical summaries
# Genome size
summary(lm(connectedness.neg ~ Genome.size..bp..CheckM1,
          data = MINT_sPLS_CheckM_stats_and_average_KEGG_completeness_and_connectedness))
# GC content
summary(lm(connectedness.neg ~ GC.CheckM1,
          data = MINT_sPLS_CheckM_stats_and_average_KEGG_completeness_and_connectedness))
# KEGG completeness
summary(lm(connectedness.neg ~ average_KEGG_completeness_per_MAG,
          data = MINT_sPLS_CheckM_stats_and_average_KEGG_completeness_and_connectedness))
```

Yes, the result is significant in all instances, although R squared values are low, suggesting a small (albeit significant) effect.

## Exploring the networks generated in ***FlashWeave***

```{r Importing the FW network, eval=FALSE, message = FALSE, warning=FALSE, echo=TRUE, results='hide', fig.show='hide'}
global_FlashWeave_network <- read_graph('/home/markoterzin/Documents/PhD/Thesis/Chapter_3_Networks/for_FlashWeave/network_output.gml', format='gml')

Closed_FlashWeave_no_metadata <- read_graph('/home/markoterzin/Documents/PhD/Thesis/Chapter_3_Networks/for_FlashWeave/Closed_and_Open_separately/FW_Closed_Reefs_no_metadata.gml', format='gml')

Open_FlashWeave_no_metadata <- read_graph('/home/markoterzin/Documents/PhD/Thesis/Chapter_3_Networks/for_FlashWeave/Closed_and_Open_separately/FW_Open_Reefs_no_metadata.gml', format='gml')

# This seems like a nice tutorial to follow from here onwards!
# Find the edge density - Density captures how many edges there are in a network divided by the total possible number of edges.
edge_density(Closed_FlashWeave_no_metadata)
edge_density(Open_FlashWeave_no_metadata)

# Visualize the graph

# Let’s size our graph and make an initial visualization. Before you make the plot, you’ll calculate the number of vertices and edges. This allows you to know if you can actually plot the entire network. Also, the ratio of nodes to edges will give you an intuition of just how dense or sparse your plot might be. Will we see a difference between closed and open reefs?

# Count the number of nodes - of course it will be the same, 1071 because nodes are MAGs:
gorder(Closed_FlashWeave_no_metadata)
gorder(Open_FlashWeave_no_metadata)
# Count the number of edges:
gsize(Closed_FlashWeave_no_metadata)
gsize(Open_FlashWeave_no_metadata)
# Seems like the closed network is more connected!

# Calculate the graph density:
graph.density(Closed_FlashWeave_no_metadata)
graph.density(Open_FlashWeave_no_metadata)

# First very ugly plot
# plot(Closed_FlashWeave_no_metadata)
# plot(Open_FlashWeave_no_metadata)
```

```{r Computing betweeness and eigen-centrality, eval=FALSE, message = FALSE, warning=FALSE, echo=TRUE, results='hide', fig.show='hide'}
# What’s the distribution of centrality?

# Recall that there are many ways that you can assess centrality of a graph. We will use two different methods you learned earlier: betweenness and eigen-centrality. Remember that betweenness is a measure of how often a given vertex is on the shortest path between other vertices, whereas eigen-centrality is a measure of how many other important vertices a given vertex is connected to. Before we overlay centrality on our graph plots, let’s get a sense of how centrality is distributed.

# Note that due to algorithmic rounding errors, we can’t check for eigen-centrality equaling a specific value; instead, we check a range.

# Calculate directed betweenness of vertices
Closed_btw <- betweenness(Closed_FlashWeave_no_metadata, directed = TRUE)

# Get a summary of retweet_btw
summary(retweet_btw)

# Calculate eigen-centrality using eigen_centrality()
Closed_ec <- eigen_centrality(Closed_FlashWeave_no_metadata, directed = TRUE)$vector
Open_ec <- eigen_centrality(Open_FlashWeave_no_metadata, directed = TRUE)$vector
# Get a summary:
summary(Closed_ec)
summary(Open_ec)
```

```{r close to zero eigen-centrality, eval=FALSE, message = FALSE, warning=FALSE, echo=TRUE, results='hide', fig.show='hide'}
# Calc proportion of vertices with eigen-centrality close to zero
almost_zero <- 1e-10
mean(Closed_ec < almost_zero)
mean(Open_ec < almost_zero)
```

42% (Closed) and 48% (Open) vertices have eigen-centrality close to zero - potentially more hub taxa in closed?

This is interesting to revisit since more hub taxa in a network is considered a proxy of increased stability based on Kajihara and Hynson review in 2024!

Different measures of centrality all try to get at the similar concept of “which vertices are most important."

```{r Ranking nodes based on eigen-centrality, eval=FALSE, message = FALSE, warning=FALSE, echo=TRUE, results='hide', fig.show='hide'}
# Get 0.95 quantile of eigen-centrality
Closed_eigen_centrality_q95 <- quantile(Closed_ec, 0.95)
Open_eigen_centrality_q95 <- quantile(Open_ec, 0.95)

# Get top 1% of vertices by eigen-centrality
Closed_top_ec <- Closed_ec[Closed_ec > Closed_eigen_centrality_q95]
Open_top_ec <- Open_ec[Open_ec > Open_eigen_centrality_q95]

# Values seem to be higher for closed sites - makes sense considering the higher edge density too?
```

```{r Modularity, eval=FALSE, message = FALSE, warning=FALSE, echo=TRUE, results='hide', fig.show='hide'}
Closed_modularity <- modularity(Closed_FlashWeave_no_metadata)
```


```{r Getting the FW adjacency matrix, eval=FALSE, message = FALSE, warning=FALSE, echo=TRUE, results='hide', fig.show='hide'}
# What information is already in the network? We can see the node and edge metadata by accessing a single node or edge.
print(V(global_FlashWeave_network))
print(E(global_FlashWeave_network))

vertex_attributes <- get.vertex.attribute(global_FlashWeave_network)
edge_attributes <- get.edge.attribute(global_FlashWeave_network)

print(vertex_attributes) 
print(edge_attributes) 

# Trying to convert to an adjacency matrix
global_FlashWeave_adj_mat <- as_adjacency_matrix(
  global_FlashWeave_network,
  type = "both",
  names = TRUE,
  sparse = F,
  attr="weight"
  )
# As matrix
global_FlashWeave_adj_mat %>% as.matrix()
```

Samuel suggested to use the NetCoMi package to get metrics on networks and to visualise.

NetCoMi’s main functions are netConstruct() for network construction, netAnalyze() for network analysis, and netCompare() for network comparison. These three functions must be executed in the aforementioned order. A further function is diffnet() for constructing a differential association network. diffnet() must be applied to the object returned by netConstruct(), and can be useful when ***comparing networks between no-take and take zones!***.

I've constructed networks in FlashWeave, so I think I can start the tutorial from here:
https://github.com/stefpeschel/NetCoMi#using-an-association-matrix-as-input

I am only supposed to provide the association matrix from FlashWeave, and I can see the QMP dataset to see how to format:

```{r Example data, eval=FALSE, message = FALSE, warning=FALSE, echo=TRUE, results='hide', fig.show='hide'}
library(SPRING) # because the QMP dataset is found here
# Load the QMP data set
data("QMP")
# Run SPRING for association estimation
fit_spring <- SPRING(QMP, 
                     quantitative = TRUE, 
                     lambdaseq = "data-specific",
                     nlambda = 10, 
                     rep.num = 10,
                     seed = 123456, 
                     ncores = 1,
                     verbose = FALSE)

# Optimal lambda
opt.K <- fit_spring$output$stars$opt.index
    
# Association matrix
assoMat <- as.matrix(SpiecEasi::symBeta(fit_spring$output$est$beta[[opt.K]],
                                        mode = "ave"))
rownames(assoMat) <- colnames(assoMat) <- colnames(QMP)
# Looking at the github page, nlambda and rep.num are set to 10 for a decreased execution time, but should be higher for real data. I am just trying to see how the assoMat object will look like, so it has no relevance for me (in fact I can make it lower too)

# OK so my FlashWeave network should be formatted as the assoMat here?
```

## ***Comparison of microbial networks***

By comparing the networks in NetCoMi between no-take and take reefs, we will be able to answer these questions:
(i) Is the overall network structure different between two groups?
(ii) Are hub taxa different between the two microbial communities?
(iii) Do the microorganisms build different “functional” groups/modules?
(iv) Are single pairs of taxa differentially associated among the groups?

Following this tutorial: https://github.com/stefpeschel/NetCoMi#network-comparison

### Network construction: separately for ***no-take*** and ***take***zones

```{r Splitting my phyloseq into open and closed reefs, eval=FALSE, message = FALSE, warning=FALSE, echo=TRUE, results='hide', fig.show='hide'}
# Split the phyloseq object into two groups
# data(amgut2.filt.phy)
# amgut_season_yes <- phyloseq::subset_samples(amgut2.filt.phy, 
#                                             SEASONAL_ALLERGIES == "yes")
# amgut_season_no <- phyloseq::subset_samples(amgut2.filt.phy, 
#                                            SEASONAL_ALLERGIES == "no")
# This is how their data looks like: two separate phyloseq objects
# amgut_season_yes
# amgut_season_no

# IMOS data - splitting into 2 phyloseqs, open and closed reefs
Closed_reefs <- phyloseq::subset_samples(pMAGs_95ANI_phyloseq,
                                        Open_or_Closed_to_fishing == "C")
Open_reefs <- phyloseq::subset_samples(pMAGs_95ANI_phyloseq,
                                        Open_or_Closed_to_fishing == "O")
```

Proportionality

```{r Network construction in NetCoMi using the proportionality metric, eval=FALSE, message = FALSE, warning=FALSE, echo=TRUE, results='hide', fig.show='hide'}
# Network construction
net_closed_open <- netConstruct(data = Closed_reefs, 
                           data2 = Open_reefs,  
                           filtTax = "none", # I will keep all the MAGs now
#                           filtTax = "highestVar",
#                           filtTaxPar = list(highestVar = 50),
                           filtSamp = "none", # my design is balanced, so no need to filter any of the samples!
#                           filtSampPar = list(highestFreq = n_yes),
                           measure = "propr", # Trying first with the proportionality metric
#                           measurePar = list(nlambda=10, 
#                                             rep.num=10),
                           normMethod = "clr", # Because these are raw counts from the propr paper, clr is done there 
                           zeroMethod = "pseudo", # introduce pseudocounts
                           zeroPar = list(pseudocount = 1), # pseudocount = 1
                           sparsMethod = "threshold", # but I will probably need to select a cutoff here as sparsification will only select edges of interest! 
                           thresh = 0.8,
#                           dissFunc = "signed", # unsigned - leading to a low distance between strongly associated taxa (positively as well as negatively). Signed - distance is highest for strongly negative associated taxa
                           verbose = 2,
                           seed = 123456) # give a seed for reproducibility of results
```

### Network analysis

The object returned by netConstruct() containing both networks is again passed to netAnalyze(). Network properties are computed for both networks simultaneously.

```{r Network Analysis, eval=FALSE, message = FALSE, warning=FALSE, echo=TRUE, results='hide', fig.show='hide'}
props_closed_open <- netAnalyze(net_closed_open, 
#                           centrLCC = TRUE, # logical indicating whether to compute centralities only for the largest connected component (LCC). If TRUE (default), centrality values of disconnected components are zero.
#                           avDissIgnoreInf = TRUE,
#                           sPathNorm = TRUE, # TRUE (default), shortest paths are normalized by average dissimilarity (only connected nodes are considered)
                           clustMethod = "cluster_fast_greedy", # Defaults to "cluster_fast_greedy" for association-based networks
                           hubPar = "degree" # character vector with one or more elements (centrality measures) used for identifying hub nodes. Centrality measures aim to identify the role of taxa in the community - identifying hubs/keystone microbes! We can look at 4 centrality measures: degree (number of adjacent nodes), eigenvector (), betweeness, closeness
#                           hubQuant = 0.95,
#                           lnormFit = FALSE, # hubs are nodes with a centrality value above the 95% quantile of the fitted log-normal distribution (if lnormFit = TRUE)
#                           normDeg = FALSE,
#                           normBetw = FALSE,
#                           normClose = FALSE,
#                           normEigen = FALSE
)
```

```{r Network summary statistics, eval=FALSE, message = FALSE, warning=FALSE, echo=TRUE, results='hide', fig.show='hide'}
summary(props_closed_open)
```

### Visual Network Comparison

```{r Network visualisation, eval=FALSE, message = FALSE, warning=FALSE, echo=TRUE, results='hide', fig.show='hide'}
plot(props_closed_open,
     sameLayout = FALSE, 
     nodeColor = "cluster",
#     nodeSize = "mclr",
     labelScale = FALSE,
     cexNodes = 1.5, 
     cexLabels = 2.5,
     cexHubLabels = 3,
     cexTitle = 3.7,
     groupNames = c("No-take zones", "Take zones"),
     hubBorderCol  = "gray40")

legend("bottom", title = "estimated association:", legend = c("+","-"), 
       col = c("slategray","hotpink4"), inset = 0.02, cex = 4, lty = 1, lwd = 4, 
       bty = "n", horiz = TRUE)
```

### Following the tutorial blindly

Because it runs for quite some time on all the 1072 MAGs, I will first try on subsets with 50, 100 and 150 MAGs - need to get the code first, I can later extend on all the 1072 MAGs.

```{r Networks on subsets with 50 100 and 150 MAGs, eval=FALSE, message = FALSE, warning=FALSE, echo=TRUE, results='hide', fig.show='hide'}
net_closed_open_50 <- netConstruct(data = Closed_reefs, 
                           data2 = Open_reefs,
                           dataType = "counts", # specifying that data (and data2) is a count matrix or object of class phyloseq.
#                           filtTax = "none", # I will keep all the MAGs now
                           filtTax = "highestVar",
                           filtTaxPar = list(highestVar = 50),
#                           filtSamp = "highestFreq",
#                           filtSampPar = list(highestFreq = n_yes),
                           measure = "spring",
                           measurePar = list(nlambda=10, 
                                             rep.num=10), # nlambda and rep.num are set to 10 and 5 for a decreased execution time, but should be higher for real data
                           normMethod = "none", # Normalization as well as zero handling is performed internally in SPRING(). Hence, we set normMethod and zeroMethod to "none"
                           zeroMethod = "none",
                           sparsMethod = "none", # set to "none" because SPRING returns a sparse network where no additional sparsification step is necessary
                           dissFunc = "signed",
                           verbose = 2, # The verbose argument is set to 3 so that all messages generated by netConstruct() as well as messages of external functions are printed
                           seed = 123456)

net_closed_open_100 <- netConstruct(data = Closed_reefs, 
                           data2 = Open_reefs,
                           dataType = "counts", # specifying that data (and data2) is a count matrix or object of class phyloseq.
#                           filtTax = "none", # I will keep all the MAGs now
                           filtTax = "highestVar",
                           filtTaxPar = list(highestVar = 100),
#                           filtSamp = "highestFreq",
#                           filtSampPar = list(highestFreq = n_yes),
                           measure = "spring",
                           measurePar = list(nlambda=10, 
                                             rep.num=10), # nlambda and rep.num are set to 10 and 5 for a decreased execution time, but should be higher for real data
                           normMethod = "none", # Normalization as well as zero handling is performed internally in SPRING(). Hence, we set normMethod and zeroMethod to "none"
                           zeroMethod = "none",
                           sparsMethod = "none", # set to "none" because SPRING returns a sparse network where no additional sparsification step is necessary
                           dissFunc = "signed",
                           verbose = 2, # The verbose argument is set to 3 so that all messages generated by netConstruct() as well as messages of external functions are printed
                           seed = 123456)

net_closed_open_150 <- netConstruct(data = Closed_reefs, 
                           data2 = Open_reefs,
                           dataType = "counts", # specifying that data (and data2) is a count matrix or object of class phyloseq.
#                           filtTax = "none", # I will keep all the MAGs now
                           filtTax = "highestVar",
                           filtTaxPar = list(highestVar = 150),
#                           filtSamp = "highestFreq",
#                           filtSampPar = list(highestFreq = n_yes),
                           measure = "spring",
                           measurePar = list(nlambda=10, 
                                             rep.num=10), # nlambda and rep.num are set to 10 and 5 for a decreased execution time, but should be higher for real data
                           normMethod = "none", # Normalization as well as zero handling is performed internally in SPRING(). Hence, we set normMethod and zeroMethod to "none"
                           zeroMethod = "none",
                           sparsMethod = "none", # set to "none" because SPRING returns a sparse network where no additional sparsification step is necessary
                           dissFunc = "signed",
                           verbose = 2, # The verbose argument is set to 3 so that all messages generated by netConstruct() as well as messages of external functions are printed
                           seed = 123456)

# just saving the network with 250 nodes as it took a while to compute
# net_closed_open_250 <- net_closed_open
# net_closed_open_1072 <- net_closed_open
```

Network analysis

NetCoMi’s netAnalyze() function is used for analyzing the constructed network(s).

By default, a heatmap of the Graphlet Correlation Matrix (GCM) is returned (with graphlet correlations in the upper triangle and significance codes resulting from Student’s t-test in the lower triangle). See ?calcGCM and ?testGCM for details.

```{r NetAnalyze for networks 50, fig.height=12, fig.width=12, eval=FALSE, message = FALSE, warning=FALSE, echo=TRUE, results='hide', fig.show='hide'}
props_closed_open_50 <- netAnalyze(net_closed_open_50, 
                           centrLCC = FALSE, # If centrLCC is set to TRUE, centralities are calculated only for nodes in the largest connected component (LCC). We set it to FALSE - Centralities are calculated for all nodes (not only for the largest connected component)
                           avDissIgnoreInf = TRUE, # Nodes with an infinite dissimilarity are ignored when calculating the average dissimilarity
                           sPathNorm = FALSE, # Shortest paths are not normalized by average dissimilarity.
                           clustMethod = "cluster_fast_greedy", # Clusters are identified using greedy modularity optimization (by cluster_fast_greedy() from igraph package
                           hubPar = c("degree", "eigenvector"), # Hubs are nodes with highest degree and eigenvector centrality at the same time.
                           hubQuant = 0.9,
                           lnormFit = TRUE, # A log-normal distribution is fitted to the centrality values to identify nodes with “highest” centrality values. Here, a node is identified as hub if for each of the three centrality measures, the node’s centrality value is above the 90% quantile (hubQuant parameter) of the fitted log-normal distribution
                           normDeg = FALSE,
                           normBetw = FALSE,
                           normClose = FALSE,
                           normEigen = FALSE)
```

```{r NetAnalyze for networks 100, fig.height=12, fig.width=12, eval=FALSE, message = FALSE, warning=FALSE, echo=TRUE, results='hide', fig.show='hide'}
props_closed_open_100 <- netAnalyze(net_closed_open_100, 
                           centrLCC = FALSE, # If centrLCC is set to TRUE, centralities are calculated only for nodes in the largest connected component (LCC). We set it to FALSE - Centralities are calculated for all nodes (not only for the largest connected component)
                           avDissIgnoreInf = TRUE, # Nodes with an infinite dissimilarity are ignored when calculating the average dissimilarity
                           sPathNorm = FALSE, # Shortest paths are not normalized by average dissimilarity.
                           clustMethod = "cluster_fast_greedy", # Clusters are identified using greedy modularity optimization (by cluster_fast_greedy() from igraph package
                           hubPar = c("degree", "eigenvector"), # Hubs are nodes with highest degree and eigenvector centrality at the same time.
                           hubQuant = 0.9,
                           lnormFit = TRUE, # A log-normal distribution is fitted to the centrality values to identify nodes with “highest” centrality values. Here, a node is identified as hub if for each of the three centrality measures, the node’s centrality value is above the 90% quantile (hubQuant parameter) of the fitted log-normal distribution
                           normDeg = FALSE,
                           normBetw = FALSE,
                           normClose = FALSE,
                           normEigen = FALSE)
```

```{r NetAnalyze for networks 150, fig.height=12, fig.width=12, eval=FALSE, message = FALSE, warning=FALSE, echo=TRUE, results='hide', fig.show='hide'}
props_closed_open_150 <- netAnalyze(net_closed_open_150, 
                           centrLCC = FALSE, # If centrLCC is set to TRUE, centralities are calculated only for nodes in the largest connected component (LCC). We set it to FALSE - Centralities are calculated for all nodes (not only for the largest connected component)
                           avDissIgnoreInf = TRUE, # Nodes with an infinite dissimilarity are ignored when calculating the average dissimilarity
                           sPathNorm = FALSE, # Shortest paths are not normalized by average dissimilarity.
                           clustMethod = "cluster_fast_greedy", # Clusters are identified using greedy modularity optimization (by cluster_fast_greedy() from igraph package
                           hubPar = c("degree", "eigenvector"), # Hubs are nodes with highest degree and eigenvector centrality at the same time.
                           hubQuant = 0.9,
                           lnormFit = TRUE, # A log-normal distribution is fitted to the centrality values to identify nodes with “highest” centrality values. Here, a node is identified as hub if for each of the three centrality measures, the node’s centrality value is above the 90% quantile (hubQuant parameter) of the fitted log-normal distribution
                           normDeg = FALSE,
                           normBetw = FALSE,
                           normClose = FALSE,
                           normEigen = FALSE)
# Saving it as it took quite some time (10h)
# props_closed_open_1072 <- props_closed_open
```

```{r, eval=FALSE, message = FALSE, warning=FALSE, echo=TRUE, results='hide', fig.show='hide'}
# summary(props_closed_open_1072)
```

```{r SPRING Network visualisation 50, fig.height=45, fig.width=45, eval=FALSE, message = FALSE, warning=FALSE, echo=TRUE, results='hide', fig.show='hide'}
networks_50_plot <- plot(props_closed_open_50, 
     sameLayout = TRUE, 
     repulsion = 0.95, # Place the nodes further apart.
     layoutGroup = "union", # a union of the two layouts is used in both groups. In doing so, the nodes are placed as optimal as possible equally for both networks
     rmSingles = "inboth",  # Removes single nodes in both networks
     nodeSize = "mclr", 
     labelScale = FALSE,
     cexNodes = 1.5, 
     cexLabels = 2.5,
     cexHubLabels = 3,
     cexTitle = 3.8,
     groupNames = c("No-take zones", "Take zones"),
     hubBorderCol  = "gray40")

legend("bottom", title = "estimated association in Networks 50:", legend = c("+","-"), 
       col = c("slategray","hotpink4"), inset = 0.02, cex = 4, lty = 1, lwd = 4, 
       bty = "n", horiz = TRUE)
```

In the network with 50 MAGs (filtTax = "highestVar", filtTaxPar = list(highestVar = 50)), we see a difference in networks computed for no-take (left) and take (right) zones. For instance, the MAGs with IDs 4392_4 (o__***SAR86***	f__D2472	g__SCGC-AAA076-P13	s__SCGC-AAA076-P13 sp902635645) and 1029_2 (f__***Puniceispirillaceae***	g__UBA8309	s__UBA8309 sp001627655) are more connected in take zones and therefore represent microbial hubs on the right plot, but not in no-take zones (left) where the MAG with ID 1956_1 (o__SAR324	f__NAC60-12	g__UBA1014	s__UBA1014 sp001469005) is the hub taxon.

How similar are these patterns for networks 100 and 150?

```{r SPRING Network visualisation 100, fig.height=45, fig.width=45, eval=FALSE, message = FALSE, warning=FALSE, echo=TRUE, results='hide', fig.show='hide'}
networks_100_plot <- plot(props_closed_open_100, 
     sameLayout = TRUE, 
     repulsion = 0.95, # Place the nodes further apart.
     layoutGroup = "union", # a union of the two layouts is used in both groups. In doing so, the nodes are placed as optimal as possible equally for both networks
     rmSingles = "inboth",  # Removes single nodes in both networks
     nodeSize = "mclr", 
     labelScale = FALSE,
     cexNodes = 1.5, 
     cexLabels = 2.5,
     cexHubLabels = 3,
     cexTitle = 3.8,
     groupNames = c("No-take zones", "Take zones"),
     hubBorderCol  = "gray40")

legend("bottom", title = "estimated association in Networks 100:", legend = c("+","-"), 
       col = c("slategray","hotpink4"), inset = 0.02, cex = 4, lty = 1, lwd = 4, 
       bty = "n", horiz = TRUE)
```

Good news - I am seeing the same hub taxa in no-take and take networks as in Network 50 plot too, however more hubs are now added too... Makes sense as I have more nodes in the networks.

```{r SPRING Network visualisation 150, fig.height=45, fig.width=45, eval=FALSE, message = FALSE, warning=FALSE, echo=TRUE, results='hide', fig.show='hide'}
networks_150_plot <- plot(props_closed_open_150, 
     sameLayout = TRUE, 
     repulsion = 0.95, # Place the nodes further apart.
     layoutGroup = "union", # a union of the two layouts is used in both groups. In doing so, the nodes are placed as optimal as possible equally for both networks
     rmSingles = "inboth",  # Removes single nodes in both networks
     nodeSize = "mclr", 
     labelScale = FALSE,
     cexNodes = 1.5, 
     cexLabels = 2.5,
     cexHubLabels = 3,
     cexTitle = 3.8,
     groupNames = c("No-take zones", "Take zones"),
     hubBorderCol  = "gray40")

legend("bottom", title = "estimated association in Networks 150:", legend = c("+","-"), 
       col = c("slategray","hotpink4"), inset = 0.02, cex = 4, lty = 1, lwd = 4, 
       bty = "n", horiz = TRUE)
```

Same here, but the more nodes I add the messier the networks are...

So - can I only show the differences between networks?

### Quantitative network comparison

Since runtime is considerably increased if permutation tests are performed, we set the permTest parameter to FALSE. See the tutorial_createAssoPerm file for a network comparison including permutation tests - ***this is important for the final results***

Since permutation tests are still conducted for the Adjusted Rand Index, a seed should be set for reproducibility.

```{r Network 50 comparison, eval=FALSE, message = FALSE, warning=FALSE, echo=TRUE, results='hide', fig.show='hide'}
comp_open_closed_50 <- netCompare(props_closed_open_50, 
                          permTest = FALSE, 
                          verbose = FALSE,
                          seed = 123456)

summary(comp_open_closed_50,
        groupNames = c("No-take zones - Network 50", "Take zones - Network 50"),
        showCentr = c("degree", "between", "closeness"), 
        numbNodes = 5)
```

```{r Network 100 comparison, eval=FALSE, message = FALSE, warning=FALSE, echo=TRUE, results='hide', fig.show='hide'}
comp_open_closed_100 <- netCompare(props_closed_open_100, 
                          permTest = FALSE, 
                          verbose = FALSE,
                          seed = 123456)

summary(comp_open_closed_100,
        groupNames = c("No-take zones - Network 100", "Take zones - Network 100"),
        showCentr = c("degree", "between", "closeness"), 
        numbNodes = 5)
```

```{r Network 150 comparison, eval=FALSE, message = FALSE, warning=FALSE, echo=TRUE, results='hide', fig.show='hide'}
comp_open_closed_150 <- netCompare(props_closed_open_150, 
                          permTest = FALSE, 
                          verbose = FALSE,
                          seed = 123456)

summary(comp_open_closed_150,
        groupNames = c("No-take zones - Network 150", "Take zones - Network 150"),
        showCentr = c("degree", "between", "closeness"), 
        numbNodes = 5)
```

### Differential association analysis

We now build a differential association network, where two nodes are connected if they are differentially associated between the two groups - ***this is super relevant to our questions!*** Also makes it easier to present this data.

Due to its very short execution time, I will first test Pearson’s correlations for estimating associations between IMOS MGD MAGs.

Fisher’s z-test is applied for identifying differentially correlated MAGs. Multiple testing adjustment is done by controlling the local false discovery rate.

Note: sparsMethod is set to "none", just to be able to include all differential associations in the association network plot (see below). However, the differential network is always based on the estimated association matrices before sparsification (the assoEst1 and assoEst2 matrices returned by netConstruct()).


```{r Trying AtlantEcoNet, eval=FALSE, message = FALSE, warning=FALSE, echo=TRUE, results='hide', fig.show='hide'}
netConstruct(Closed_reefs,
             measure = "flashweave",
             measurePar = list(sensitive = TRUE,
                               heterogeneous = FALSE,
                               normalize = FALSE,
					     julia_path='/home/markoterzin/julia-1.8.1/bin'),
			   zeroMethod = "pseudo",
			   zeroPar = list(pseudocount = 0.5),
			   normMethod = "clr",
                           filtTax = "highestVar",
                           filtTaxPar = list(highestVar = 50),
                           filtSamp = "totalReads",
                           filtSampPar = list(totalReads = 1000),
                           verbose = 3)
```

```{r Network 50 with Pearson correlation, eval=FALSE, message = FALSE, warning=FALSE, echo=TRUE, results='hide', fig.show='hide'}
net_closed_open_50_pearson_diffnet <- netConstruct(data = Closed_reefs, 
                           data2 = Open_reefs,
                           filtTax = "highestVar",
                           filtTaxPar = list(highestVar = 50),
                           measure = "pearson",
                           normMethod = "clr",
                           sparsMethod = "none",
                           thresh = 0.2,
                           verbose = 3)
```

```{r Network 150 with Pearson correlation, eval=FALSE, message = FALSE, warning=FALSE, echo=TRUE, results='hide', fig.show='hide'}
net_closed_open_150_pearson_diffnet <- netConstruct(data = Closed_reefs, 
                           data2 = Open_reefs,
                           filtTax = "highestVar",
                           filtTaxPar = list(highestVar = 150),
                           measure = "pearson",
                           normMethod = "clr",
                           sparsMethod = "none",
                           thresh = 0.2,
                           verbose = 3)
```

```{r Differential association analysis Network 50, eval=FALSE, message = FALSE, warning=FALSE, echo=TRUE, results='hide', fig.show='hide'}
# Differential network construction
diff_open_closed_50 <- diffnet(net_closed_open_50_pearson_diffnet,
                       diffMethod = "fisherTest", 
                       adjust = "lfdr")
```

```{r Differential association analysis Network 150, eval=FALSE, message = FALSE, warning=FALSE, echo=TRUE, results='hide', fig.show='hide'}
# Differential network construction
diff_open_closed_150 <- diffnet(net_closed_open_150_pearson_diffnet,
                       diffMethod = "fisherTest", 
                       adjust = "lfdr")
```

```{r Differential Networks 50 plot, fig.height=25, fig.width=45, eval=FALSE, message = FALSE, warning=FALSE, echo=TRUE, results='hide', fig.show='hide'}
# Differential network plot
plot(diff_open_closed_50, 
     cexNodes = 0.8, 
     cexLegend = 3,
     cexTitle = 4,
     mar = c(2,2,8,5),
     legendGroupnames = c("group 'No-take reefs'", "group 'Take reefs'"),
     legendPos = c(0.7,1.6))
```

```{r Differential Networks 150 plot, fig.height=25, fig.width=45, eval=FALSE, message = FALSE, warning=FALSE, echo=TRUE, results='hide', fig.show='hide'}
# Differential network plot
plot(diff_open_closed_150, 
     cexNodes = 0.8, 
     cexLegend = 3,
     cexTitle = 4,
     mar = c(2,2,8,5),
     legendGroupnames = c("group 'No-take reefs'", "group 'Take reefs'"),
     legendPos = c(0.7,1.6))
```

In the differential network shown above, edge colors represent the direction of associations in the two groups. If, for instance, two OTUs are positively associated in group 1 (No-take zones) and negatively associated in group 2 (Take zones), the respective edge is colored in cyan/blue.

We also take a look at the corresponding associations by constructing association networks that include only the differentially associated MAGs.


```{r Only differentially associated MAGs in Network 50, fig.height=25, fig.width=45, eval=FALSE, message = FALSE, warning=FALSE, echo=TRUE, results='hide', fig.show='hide'}
# Analysing networks first
props_open_closed_50_pears <- netAnalyze(net_closed_open_50_pearson_diffnet, 
                                 clustMethod = "cluster_fast_greedy",
                                 weightDeg = TRUE,
                                 normDeg = FALSE,
                                 gcmHeat = FALSE)
# Identify the differentially associated OTUs
diffmat_sums <- rowSums(diff_open_closed_50$diffAdjustMat)
diff_asso_names <- names(diffmat_sums[diffmat_sums > 0])

plot(props_open_closed_50_pears, 
     nodeFilter = "names",
     nodeFilterPar = diff_asso_names,
     nodeColor = "gray",
     highlightHubs = FALSE,
     sameLayout = TRUE, 
     layoutGroup = "union",
     rmSingles = FALSE, 
     nodeSize = "clr",
     edgeTranspHigh = 20,
     labelScale = FALSE,
     cexNodes = 1.5, 
     cexLabels = 3,
     cexTitle = 3.8,
     groupNames = c("No-take reefs", "Take reefs"),
     hubBorderCol  = "gray40")

legend(-0.15,-0.7, title = "estimated correlation:", legend = c("+","-"), 
       col = c("#009900","red"), inset = 0.05, cex = 4, lty = 1, lwd = 4, 
       bty = "n", horiz = TRUE)
```

```{r Only differentially associated MAGs in Network 150, fig.height=25, fig.width=45, eval=FALSE, message = FALSE, warning=FALSE, echo=TRUE, results='hide', fig.show='hide'}
# Analysing networks first
props_open_closed_150_pears <- netAnalyze(net_closed_open_150_pearson_diffnet, 
                                 clustMethod = "cluster_fast_greedy",
                                 weightDeg = TRUE,
                                 normDeg = FALSE,
                                 gcmHeat = FALSE)
# Identify the differentially associated OTUs
diffmat_sums <- rowSums(diff_open_closed_150$diffAdjustMat)
diff_asso_names <- names(diffmat_sums[diffmat_sums > 0])

plot(props_open_closed_150_pears, 
     nodeFilter = "names",
     nodeFilterPar = diff_asso_names,
     nodeColor = "gray",
     highlightHubs = FALSE,
     sameLayout = TRUE, 
     layoutGroup = "union",
     rmSingles = FALSE, 
     nodeSize = "clr",
     edgeTranspHigh = 10,
     labelScale = FALSE,
     cexNodes = 1.5, 
     cexLabels = 3,
     cexTitle = 3.8,
     groupNames = c("No-take reefs", "Take reefs"),
     hubBorderCol  = "gray40")

legend(-0.15,-0.7, title = "estimated correlation:", legend = c("+","-"), 
       col = c("#009900","red"), inset = 0.05, cex = 4, lty = 1, lwd = 4, 
       bty = "n", horiz = TRUE)
```

Looks really messy, I don't know how to interpret and why these associations are considered differential...

# Saving the R object (for downstream analysis)

```{r Save an R object, eval=TRUE, message = FALSE, warning=FALSE, echo=TRUE}
save.image(file = "/home/marko-terzin/Documents/PhD/Thesis/Chapter_3_IMOS-MGD_MAGs/cleaned_code/Figure_4/Figure_4.RData")
```

The final Fig. 4 was created in Inkscape.